% Chapter 1

\chapter{Otimização de Knuth-Yao} % Main chapter title

\label{Knuth-Yao} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

\section{Avisos (Temporário)}

Eu estou usando algumas notações que eu não tenho certeza se são razoáveis.
\begin{itemize}
\item $[i..j] := \{k \in \B{N} \mid i \leq k \leq j\}$ (um intervalo)
\item $[n] := [1..n]$ (o intervalo de um até n)
\item $[[n]] := \{[i..j] \mid i,j \in \B{N} \text{ e } 1 \leq i \leq j \leq n\}$ (todos os subintervalos de $[1..n]$)
\end{itemize}  

Além disso, eu defino funções sobre intervalos (exemplo: $f : [[n]] \to \B{R}$) e depois uso elas como se fossem funções sobre $\B{N}^2$ (exemplo: $f(i,j)$ ao invés de $f[i,j]$). Tudo bem?

%----------------------------------------------------------------------------------------

\section{Concatenação de Custo Mínimo}

Para apresentar a técnica da otimização de Knuth-Yao, vamos introduzir o problema da \textit{Concatenação de Custo Mínimo}. O problema consiste em um inteiro $n$, um vetor $v \in \B{R}^n_+$ e duas operações:

\begin{enumerate}
\item Criar um novo vetor unitário $x \in \B{R}_+$. Esta operação tem custo $x$.
\item Concatenar dois vetores $a \in \B{R}^p$ e $b \in \B{R}^q$ já existentes. Esta operação tem custo $\sum \limits_{i=1}^p a_i + \sum \limits_{i=1}^q b_i$.
\end{enumerate}

Queremos realizar uma sequência destas operações de forma a obter um vetor idêntico a $v$. Dentre todas as possíveis, queremos a sequência de menor custo possível. \\

Precisamos de duas observações, qualquer vetor de tamanho 1 deve ser gerado com a primeira operação e qualquer vetor de tamanho maior do que 1 deve ser obtido pela concatenação de dois outros vetores um prefixo dele e outro sufixo dele. Isso nos diz que todos os vetores intermediários necessários para gerar $v$ de maneira ótima são subvetores\footnote{Um vetor $v$ é dito subvetor de um vetor $u$ se existem índices $i$,$j$ tais que $u[i..j] = v$} de $v$, já que se um vetor não é subvetor de $v$ ele nunca vai ajudar a gerar $v$. Com isso, concluímos uma recorrência que nos dá o custo mínimo necessário para gerar $v$. 

$$
f(i,j) = \begin{cases}
    v_i & \text{se } i = j, \\
    \min\limits_{i \leq k < j} \Big\{ f(i,k) + f(k+1,j) \Big\} + \sum\limits_{k=i}^j v_k & \text{c.c.} \\
\end{cases}
$$

A recorrência acima pode ser resolvida facilmente com programação dinâmica em tempo $O(n^3)$.
\begin{algorithm}
\caption{Concatenação de Custo Mínimo $O(n^3)$}
\label{MinCostConcat}
\begin{algorithmic}[1]
\Function{MinCostConcat}{v, n}
\State \Return \text{resposta}
\EndFunction
\end{algorithmic}
\end{algorithm}

Vamos apresentar uma técnica que nos ajuda a resolver este problema em tempo $O(n^2)$ e pode ser adaptada para vários outros problemas.

%----------------------------------------------------------------------------------------

\section{A Desigualdade Quadrangular}
Para ajudar nisso, vamos escrever $f$ de uma maneira mais genérica.

\begin{defi}[Recorrência de Intervalos] \label{rec_int}
Dizemos que uma recorrência $f : [[n]] \to \B{R}$ é de intervalos se existe, para todo $k \in [1..n]$, uma função $f_k : \{[i..j] \in \B{N}^2 \mid 1 \leq i \leq k < j \leq n \} \to \B{R}$ que depende apenas de $f_{k'}(i',j')$ onde $[i',j'] \subset [i,j]$ e $i' \leq k' < j'$ e uma função $f_\bullet : [[n]] \to \B{R}$ tais que

$$
f(i,j) = \begin{cases}
    f_\bullet (i,j) & \text{se } i = j, \\
    \min\limits_{i \leq k < j} \Big\{ f_k(i,j) \Big\} + f_\bullet (i,j) & \text{c.c.} \\
\end{cases}
$$

Além disso, chamamos $f_k(i,j)$ de corte do estado $(i,j)$ no ponto $k$ e $f_\bullet(i,j)$ de constante do estado $(i,j)$.
\end{defi}

Se definirmos $f_\bullet : [i,j] \in [[n]] \mapsto \sum\limits_{k=i}^j v_k$ e, para todo $k \in [n]$, $f_k : [i,j] \in \{ \B{N}^2 \mid 1 \leq i \leq k < j \leq n \} \mapsto f(i,k) + f(k+1,j)$, temos $f$ escrita como recorrência de intervalos.

\begin{defi}[Monótono nos Intervalos] \label{mon_int}
Dizemos que uma função $w : [[n]] \to \B{R}$ é monótona nos intervalos se, para todo $[i',j'] \subseteq [i,j] \in [[n]]$,
$$ w(i',j') \leq w(i,j) $$
\end{defi}

\begin{prop}
$f$ é monótona nos intervalos.
\end{prop}

\begin{proof}
Prova vazia.
\end{proof}

\begin{defi}[Desigualdade Quadrangular] \label{qi}
Dizemos que uma função $w : [[n]] \to \B{R}$ respeita a desigualdade quadrangular se para todo $i,i',j,j' \in \B{N}$ tais que $1 \leq i \leq i' \leq j \leq j' \leq n$ vale
$$ w(i,j) + w(i',j') \leq w(i,j') + w(i',j) $$
\end{defi}

\begin{prop}
$f$ respeita a desigualdade quadrangular.
\end{prop}

\begin{proof}
Prova vazia.
\end{proof}

Definimos $f_* : [i,j] \in [[n]] \mapsto \min\limits_{i \leq k < j} \Big\{ k \mid f(i,j) = f_k(i,j) \Big\}$, ou seja, o ponto de corte do estado $(i,j)$ que gera uma resposta ótima e tem o menor índice. Para poder otimizar o código que usamos para calcular $f$, queremos rovar e explorar a seguinte propriedade sobre esta recorrência

\begin{equation} \label{knuthyao}
f_*(i,j-1) \leq f_*(i,j) \leq f_*(i+1,j) \text{, para todo } [i,j] \in [[n]]
\end{equation}

\begin{prop} \label{qi_to_knuthyao}
Se uma recorrência $f$ é uma recorrência de intervalos (\ref{rec_int}) que respeita \ref{qi} e é monótona nos intervalos (\ref{mon_int}), vale \ref{knuthyao}.
\end{prop}

A proposição \ref{qi_to_knuthyao} (apresentada de forma diferente) foi provada em \cite{Yao:1980}. Vamos apresentar aqui uma versão adaptada da prova.

\begin{proof}
Prova vazia.
\end{proof}

\section{Otimização}

Sabendo que para a função $f$ vale \ref{knuthyao}, podemos alterar o algoritmo \ref{MinCostConcat} gerando um novo algoritmo de complexidade $O(n^2)$ para calcular $f$. Se calcularmos, junto com $f$, os valores de $f_*$, podemos limitar os testes feitos para calcular cada estado de $f$. \\
É importante notar que para todos estados $(i,j)$ com $i < j$, precisamos conhecer o valor de $f_*(i+1, j)$ e $f_*(i,j-1)$ antes de calcular $f(i,j)$, ou seja, os estados $(i+1,j)$ e $(i,j-1)$ devem ser calculados antes de $(i,j)$. Essa restrição não ocorria na ultima versão deste algoritmo. Para resolver isso, basta iterar pelos estados em ordem de tamanho, ou seja, primeiro calculamos todos os estados $(i,j)$ onde $j-i = 1$, depois aqueles onde $j-i = 2$ e assim por diante.

\begin{algorithm}
\caption{Concatenação de Custo Mínimo $O(n^2)$}
\label{MinCostConcatOpt}
\begin{algorithmic}[1]
\State \Return \text{resposta}
\end{algorithmic}
\end{algorithm}

\begin{prop}
O algoritmo \ref{MinCostConcatOpt} tem tempo $O(n^2)$.
\end{prop}
