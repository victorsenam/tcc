\section{SMAWK}
\label{SMAWK}

%----------------------------------------------------------------------------------------

Nesta seção discutiremos o algoritmo SMAWK. Este algoritmo tem a mesma função do que a otimização divisão e conquista, porém, precisa que a matriz seja totalmente monótona, não apenas monótona, e tem uma complexidade assintótica melhor do que aquele. Ele é conhecido pela sua aplicação no problema de encontrar um vértice mais distante de cada vértice num polígono convexo em tempo linear~\cite{Aggarwal:1987}, mas pode ser usado em vários outros problemas, assim como a otimização da divisão e conquista.

Dada uma matriz $A \in \B{Q}^{n \times m}$, listamos os casos em que este algoritmo se aplica:
\begin{itemize}
    \item Se $A$ é totalmente monótona convexa ou côncava nas linhas podemos encontrar os índices de mínimos e máximos das linhas em tempo $\Cl{O}(n + m)$;
    \item Se $A$ é totalmente monótona convexa ou côncava nas colunas podemos encontrar os índices de mínimos e máximos das colunas em tempo $\Cl{O}(n + m)$.
\end{itemize}

Apresentaremos o caso onde $A$ é totalmente monótona convexa nas linhas e estamos interessados nos índices de mínimos. É fácil manipular o algoritmo para trabalhar com os outros casos.

%----------------------------------------------------------------------------------------

\subsection{Técnica primordial} \label{SMAWK:primordial}
Para facilitar a compreensão do algoritmo SMAWK, iremos apresentar uma técnica parecida com a otimização da divisão e conquista, apresentada na Seção~\ref{DivConq}, e mostrar uma otimização desta técnica que leva ao algoritmo SMAWK.

Dada uma matriz~$A \in \B{Q}^{n \times m}$ totalmente monótona convexa por linhas, queremos encontrar o índice de mínimo de cada uma das linhas de~$A$. Se, para uma dada linha~${ i \in [2 \tdots n-1] }$, conhecermos os índices~$\ell$ e~$r$ de mínimos das linhas~${ i-1 }$ e~${ i+1 }$, sabemos, pela monotonicidade de~$A$ que o índice de mínimo da linha~$i$ está em~${ [\ell \tdots r] }$. Além disso, se~${ i = 1 }$ e~${ \ell = 1 }$ ou se~${ i = n }$ e~${ r = m }$, o resultado descrito continua valendo.

Já que~$A$ é totalmente monótona, remover qualquer linha de~$A$ mantém a total monotonicidade e não altera o índice de mínimo de outra linha. Graças a este fato, podemos remover todas as linhas pares da matriz, encontrar os mínimos recursivamente para todas as linhas restantes e depois utilizar as respostas conhecidas para calcular os índices de mínimos das linhas pares. Vamos mostrar que esta última parte, encontrar os mínimos das linhas pares dados os mínimos das outras, custa tempo~$\Cl{O}(n+m)$.

Definimos, para cada~$i$ ímpar, o valor~$t_i$ que representa o índice de mínimo da~$i$-ésima linha, além dos valor~${ t_0 = 1 }$ , caso~$n$ seja par, o valor~${ t_{n+1} = m }$. Para cada linha~$i$ par, o parágrafo anterior sugere buscar o mínimo desta linha entre as posições~$t_{i-1}$ e~$t_{i+1}$. Podemos escrever o tempo gasto para encontrar o mínimo de cada uma das linhas pares como~${ \sum\limits_{ i \in [n] \text{ par} }( t_{i+1} - t_{i-1} ) }$ e concluir, desta expressão, que o tempo gasto ao todo é~$\Cl{O}(n+m)$. 

Considerando que remover todas as linhas pares de uma matriz pode ser realizado em tempo~$\Cl{O}(1)$, é fácil ver que o tempo de execução total deste algoritmo é~$\Cl{O}((n+m)\lg(n)$, já que só é possível remover todas as linhas pares~$\Cl{O}(\lg(n))$ vezes.

%----------------------------------------------------------------------------------------

\subsection{Reduce} \label{SMAWK:reduce}
Chamamos de ótimas as células de uma matriz que são o mínimo de alguma linha e as colunas que contém pelo menos uma célula ótima. Lembre que a definição de mínimo permite apenas um mínimo por linha, portanto, uma matriz contém no máximo~$n$ colunas ótimas.

Queremos agilizar a técnica apresentada acima. Para isso, vamos adicionar a nova hipótese de que a matriz~$A$ é quadrada, ou seja,~$n = m$. A cada passo, removemos as~$\floor{n/2}$ linhas pares da matriz, gerando uma nova matriz $A'$, resolvemos o problema recursivamente em~$A'$ e usamos a solução de~$A'$ para encontrar os mínimos das linhas restantes de~$A$. Quando removemos linhas da nossa~$A$, ela deixa de ser quadrada e passa a ser uma matriz com mais colunas do que linhas, isto é,~$m \geq n$. Queremos remover colunas não ótimas dessa matriz com mais colunas do que linhas fazendo com que a matriz resultante se torne quadrada.  

Vamos desenvolver o algoritmo \textsc{Reduce} a partir de um índice de linha~$k$ e de algumas invariantes: 
\begin{enumerate}
    \item $k \in [1 \tdots n]$, \label{invar:Reduce0}
    \item apenas colunas não ótimas foram removidas da matriz e \label{invar:Reduce1}
    \item toda célula em uma coluna de índice menor ou igual a~$k$ que possua índice de linha menor do que seu índice de coluna não é ótima. A Figura~\ref{figure:Reduce1} representa, preenchido em azul, a célula~$(k,k)$ e, pontilhado em preto, as células que, segundo esta invariante, não são ótimas. \label{invar:Reduce2}
\end{enumerate}

\begin{figure}[h]
    \centering
    \input{Figures/SMAWK_Reduce1.tikz}
    \caption{Invariante~\ref{invar:Reduce2} do \textsc{Reduce}.} \label{figure:Reduce1}
\end{figure}

Vamos comparar~$A[k][k]$ com~$A[k][k+1]$ e considerar dois casos. Em cada um dos casos, concluiremos que algumas células da matriz $A$ são não ótimas. A Figura~\ref{figure:Reduce2} mostra as células que não são ótimas em cada um dos casos. Quando~$A[k][k] > A[k][k+1]$ as células hachuradas em vermelho não são ótimas. No caso contrário as células com linhas verticais verdes não são ótimas. Vamos provar estas afirmações.

\begin{figure}[h]
    \centering
    \input{Figures/SMAWK_Reduce2.tikz}
    \caption{Casos do \textsc{Reduce}.} \label{figure:Reduce2}
\end{figure}

No primeiro caso, em que~$A[k][k] > A[k][k+1]$, vamos mostrar que as entradas com índice de linha maior ou igual a~$k$ na coluna~$k$ não são ótimas. Primeiramente, a célula~$(k,k)$ não é ótima como consequência direta da desigualdade. Tome uma linha~${ i > k }$ qualquer, pela total monotonicidade de~$A$ vale que~${ A[i][k] > A[i][k+1] }$, logo, a célula~$(i,k)$ não é ótima.

No outro caso, em que~$A[k][k] \leq A[k][k+1]$, vamos mostrar que as células da coluna~$k+1$ com índices de linha menores ou iguais a~$k$ não são ótimas. A célula~$(k,k+1)$ não é ótima. Se~${ i < k }$ é uma linha qualquer de~$A$, pela total monotonicidade de~$A$, vale~${ A[i][k] \leq A[i][k+1] }$, logo, a célula~$(i,k+1)$ não é ótima.

Com estas observações estamos prontos para deduzir um algoritmo que elimina exatamente~${ m-n }$ colunas de~$A$. 

\newcommand{\Reduce}{\textsc{Reduce}}
\begin{algorithm}[H]
\caption{Algoritmo $\Reduce$}
\label{SMAWK:algo:Reduce}
\begin{algorithmic}[1]
\Function{\Reduce}{A}
    \State $k \rec 1$
    \While{ $A$ tem mais colunas do que linhas} \label{SMAWK:Reduce:loop}
        \If{$A[k][k] > A[k][k+1]$} 
            \State Remove a coluna~$k$
            \State $k \rec \max(1,k-1)$
        \Else
            \If{$k = n$}
                \State Remove a coluna~$k+1$
            \Else
                \State $k \rec k+1$
            \EndIf
        \EndIf
    \EndWhile
    \State \Return $A$
\EndFunction
\end{algorithmic}
\end{algorithm}

Mostraremos que as invariantes são válidas neste algoritmo. Olhamos para o primeiro passo.~$k = 1$, nenhuma coluna foi removida ainda e não há elementos com índices de linha e coluna menores do que~$k$, logo as Invariantes~\eqref{invar:Reduce0},~\eqref{invar:Reduce1} e~\eqref{invar:Reduce2} valem. Em todo início do enquanto da linha~\ref{SMAWK:Reduce:loop} a célula~$A[k][k+1]$ existe, uma vez que~${ k \leq n }$ e~${ n < m }$. Consideramos o caso onde~${ A[k][k] > A[k][k+1] }$. A Invariante~\eqref{invar:Reduce0} sempre se mantém trivialmente. Já provamos que a coluna~$k$ não é ótima neste caso, o que faz com que a Invariante~\eqref{invar:Reduce1} se mantenha mesmo após a remoção da coluna~$k$. Agora, se~${ k=1 }$, vale~\eqref{invar:Reduce2} por vacuidade e, caso contrário, já que~$k$ decresce, a Invariante~\eqref{invar:Reduce2} também se mantém. 

No caso onde valem~$A[k][k] \leq A[k][k+1]$ e~$k = n$ foi provado que os elementos de linhas menores ou iguais a~$k$ na coluna coluna~$k+1$ não são ótimos. Já que~${ k = n }$, isto representa toda a coluna~${ k+1 }$, assim, removê-la mantém a Invariante~\eqref{invar:Reduce1}. As outras duas invariantes se mantém trivialmente. Finalmente, resta apenas considerar o caso onde~$A[k][k] \leq A[k][k+1]$ e $k < n$. Foi provado, novamente, que as células com índices menores do que~${ k + 1 }$ na coluna~${ k + 1 }$ não são ótimos, assim, incrementar o~$k$ mantém a Invariante~\eqref{invar:Reduce2}. As outras duas invariantes também se mantém trivialmente neste caso. 

Além disso, o algoritmo, a cada passo, incrementa~$k$ ou remove uma coluna de~$A$. Sabemos que~$k$ nunca passa de~$n$ e, já que a matriz tem~$m$ colunas, não podemos remover mais do que~$m$ colunas. Supondo que, a cada remoção de coluna,~$k$ seja decrementado, chegamos a uma quantidade máxima de~$2m + n$ passos. Supondo que as remoções sejam feitas em tempo constante, o tempo de cada passo é constante, portanto, atingimos uma complexidade de~$\Cl{O}(m)$ operações no algoritmo $\Reduce$, já que $n \leq m$.

%----------------------------------------------------------------------------------------

\subsection{SMAWK}
\newcommand{\SMAWK}{\textsc{SMAWK}}

Recebemos uma matriz~$A$ totalmente monótona convexa por linhas. Primeiramente, vamos fazer com que a matriz se torne quadrada mantendo os índices de mínimos das linhas. Se~$A$ tem mais colunas do que linhas, basta aplicar o~$\Reduce$. Se~$A$ tem mais linhas do que colunas, podemos adicionar colunas com entradas~${ +\infty }$ até que ela se torne quadrada.

\begin{algorithm}[h]
\caption{Algoritmo $\SMAWK$}
\label{SMAWK:algo:SMAWK}
\begin{algorithmic}[1]
\Function{\SMAWK}{A}
    \If{$A$ tem exatamente uma linha}
        \State $A$ é uma matriz~$1 \times 1$ e a resposta é trivial
    \Else
        \State $A'$ é a matriz~$A$ sem as linhas pares
        \State $\SMAWK(\Reduce(A'))$
        \For{$i$ linha ímpar de $A$}
            \State $l \rec 1$ e $r \rec m$
            \If{$i > 1$}
                \State $l \rec$ índice de mínimo da linha~$i - 1$
            \EndIf
            \If{$i < n$}
                \State $r \rec$ índice de mínimo da linha~$i + 1$
            \EndIf
            \State Busca o índice de mínimo da linha~$i$ entre~$l$ e~$r$, inclusive
        \EndFor
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Agora estamos prontos para descrever e aplicar o algoritmo~$\SMAWK$. Vamos usar a ideia da técnica primordial da Subseção~\ref{SMAWK:primordial}, porém, vamos aplicar o algoritmo~$\Reduce$ a cada passo para melhorar a complexidade da solução. Em cada chamada de~$\SMAWK$, recebemos uma matriz~$A$ quadrada, resolvemos o problema recursivamente para a submatriz~$A'$ que consiste das linhas ímpares de~$A$ tomando o cuidado de aplicar o~$\Reduce$ nesta antes de realizar a chamada recursiva, e, depois, utilizamos estes resultados para calcular os mínimos das linhas restantes. O Algoritmo~\ref{SMAWK:algo:SMAWK} descreve este processo.

%----------------------------------------------------------------------------------------

\subsection{Análise}
O tempo gasto pelo algoritmo~$\SMAWK$ depende apenas da dimensão~$n$ da matriz recebida. Seja~$T(n)$ o tempo gasto pelo algoritmo para todo~$n \geq 1$. Sabemos que~$T(1) = \Cl{O}(1)$. Assumimos que, dada uma matriz~$A$, sabemos gerar uma matriz~$A'$ que consiste apenas das linhas ímpares de~$A$ em tempo~$\Cl{O}(1)$. Com~$n > 1$, geramos esta matriz, que tem~$\floor{\frac{n}{2}}$ linhas, e aplicamos o~$\Reduce$ nela, gastando tempo~$\Cl{O}(n)$. Após este procedimento, determinamos os mínimos das linhas pares de~$A$ na forma descrita na Subseção~\ref{SMAWK:primordial}, o que custa tempo~$\Cl{O}(n)$. Assim, para todo~${ n > 1 }$, vale que~${ T(n) = \Cl{O}(n) + T(\floor{\frac{n}{2}}) }$, o que nos leva a~${ T(n) = \Cl{O}(n) }$.

Se a matriz recebida tiver menos colunas do que linhas, a transformação inicial custa tempo~$\Cl{O}(n)$, no outro caso, custa tempo~$\Cl{O}(m)$, onde~$m$ é a quantidade de colunas. Assim, podemos escrever a complexidade no caso geral como~$\Cl{O}(n+m)$.

%----------------------------------------------------------------------------------------

\subsection{Implementação}
Queremos encontrar uma maneira eficiente de remover as linhas pares da matriz, mas não podemos gerar explicitamente uma nova matriz. Queremos representar, a cada chamada, todas as linhas que podem ser visitadas. Inicialmente, todas as linhas visitáveis da matriz são aquelas da forma~${ 1 + k }$ onde~$k$ é um inteiro não negativo. Após remover as linhas pares, as visitáveis são da forma~${ 1 + 2k }$, depois~${ 1 + 4k }$ e assim por diante. Após~$t$ remoções, todas elas são representadas por~${ 1 + 2^tk }$ para algum~$k$ inteiro não negativo. Assim, passa passar o parâmetro~$t$ na recursão e basta incrementar~$t$ para remover tais linhas.

Precisamos representar as colunas visitáveis em~$A$. Já que não há uma regra fixa para a remoção de colunas, precisamos de alguma estrutura de dados que nos permita iterar pelos seus valores em ordem e remover um valor eficientemente. Guardaremos, em uma lista duplamente ligada, todos os índices de colunas válidos. Já que, durante uma chamada de~$\SMAWK$, iteramos pelas colunas e todas as remoções realizadas são na coluna atual ou alguma coluna adjacente à atual, cada remoção é realizada em $\Cl{O}(1)$. Após resolver o problema recursivamente, precisamos recuperar a lista ligada do início da chamada para podermos descobrir os valores de mínimo nas linhas ímpares daquela matriz. Para isso, basta, ao começo de cada chamada, criar uma cópia da lista ligada original, o que é feito em~$\Cl{O}(n)$ e, portanto, não afeta a análise do tempo do algoritmo. Note que a criação desta estrutura de dados e as cópias dela em cada chamada recursiva custam espaço~$\Cl{O}(m)$.

Antes de chamar o~$\SMAWK$ pela primeira vez, é necessário garantir que a matriz~$A$ seja quadrada. Se a quantidade de linhas é maior do que a quantidade de colunas, precisamos adicionar várias colunas com entradas~$+\infty$ em tempo~$\Cl{O}(1)$. Lembre, da Seção~\ref{Introducao}, que as matrizes são sempre representadas por~$(f,n,m)$ onde~$f$ é uma função,~$n$ é a quantidade de linhas de uma matriz e~$m$ é a quantidade de colunas da matriz. Se recebermos uma entrada tal que~${ n > m }$, basta gerar uma nova função~$h$ tal que, para todo~${ i \in [n] }$ e~${ j \in [m] }$, vale que~${ h(i,j) = f(i,j) }$ e, para todo~$i,j$ diferente destes, vale que~${ h(i,j) = +\infty }$ e podemos passar a matriz~$(h,n,n)$ adiante ao invés da original. Após realizar este tratamento, basta inicializar a lista ligada referente às colunas da matriz em tempo~$\Cl{O}(m)$ e aplicar o~$\Reduce$ nesta, o que trata o caso onde~${ n < m }$ e não faz nada em qualquer outro caso.
 
A implementação em C++ do algoritmo apresentado, levando em conta as considerações acima, leva o nome \texttt{SMAWK.cpp}.

%----------------------------------------------------------------------------------------

\subsection{Aplicações} \label{SMAWK:Appl}
Como mencionado no início desta seção, a técnica apresentada aqui pode ser usada para resolver o problema de encontrar todos os pares de pontos mais distantes num polígono convexo em tempo~$\Cl{O}(n)$. Além deste, Aggarwal~\cite{Aggarwal:1987} mostrou a aplicação do~$\SMAWK$ em vários problemas de geometria computacional.

Além disso, na Seção~\ref{Monge} foi apresentado o Problema~\ref{ Monge:example }, formulado com programação dinâmica e resolvido com o algoritmo~$\SMAWK$.
