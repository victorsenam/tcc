\section{Busca em matrizes online}
\label{Online}

Nesta seção começamos a estudar formas de encontrar índices ótimos em matrizes onde certas entradas são desconhecidas à priori. Inicialmente o formato das matrizes abordadas será explicitado juntamente com um exemplo de um caso específico interessante desta técnica apresentado por Galil e Park~\cite{Galil:1992}. Na Seção~\ref{FullyDynamic} buscaremos generalizar a técnica apresentada aqui para outras matrizes online.

Para conseguir lidar com matrizes que não são inteiramente conhecidas à priori, devemos explicar quais dependências podem aparecer e quais não podem, para isso, é útil descrever matrizes online segundo a Definição~\ref{Online:matrix}.

\begin{defi}[Matriz online] \label{Online:matrix}
Dizemos que uma matriz~$A \in \B{Q}^{n \times n}$ com vetor de índices de mínimos de linhas~$R$ é online nas linhas se para todo~$i,j \in [n]$ com~$i \neq j$ o valor de~$A[i][i]$ é conhecido à priori e os valores de~$A[i][j]$ podem depender de~$R[j]$. Isto é, em uma matriz online, a diagonal é conhecida e as outras entradas de uma \textbf{coluna}~$j$ qualquer dependem do índice do mínimo da \textbf{linha}~$j$ correspondente.

Similarmente, dizemos que uma matriz é online nas colunas quando as entradas de suas diagonais são conhecidas à priori porém uma entrada~$A[i][j]$ fora da diagonal pode depender do índice de mínimo da coluna~$i$.
\end{defi}

Note que a definição permite que outras entradas além das diagonais sejam conhecidas à priori. Dizemos ainda que uma entrada da matriz está disponível se é possível descobrir seu valor, isto é, ela era conhecida à priori ou ela só depende de informações já calculadas.

Nesta seção exploraremos especificamente o caso onde a matriz é triangular inferior, isto é, cada entrada~$A[i][j]$ da matriz onde~$i \geq j$ é indefinida. Vamos descobrir métodos para encontrar índices ótimos nestas matrizes quando elas forem totalmente monótonas convexa ou côncavas. O Problema~\ref{Online:prob} ilustra a utilidade de trabalhar com matrizes deste tipo.

\begin{prob} \label{Online:prob}
Dada uma matriz de custos~$C \in \B{Q}^{n \times n}$, computar o vetor~$E$ tal que~$E[1] = 0$ e para todo~$i \in [1 \tdots n]$ vale~$E[i] = \min\limits_{j < i} C[i][j] + E[j]$.
\end{prob}

Com uma matriz~$C$ e um vetor~$E$ definidos como no Problema~\ref{Online:prob}, criamos a matriz~$B \in \B{Q}^{n \times n}$ de forma que para todo~$i,j \in [n]$ vale
\begin{equation} \label{Online:Bmat}
    B[i][j] = \begin{cases}
        \text{indefinida} & \text{, se } i \leq j \text{ e } \\
        C[i][j] + E[j]    & \text{, caso contrário.}
    \end{cases}
\end{equation}

Primeiramente, é fácil observar que a matriz~$B$ é online nas linhas e triangular inferior, além disso, se~$R$ é o vetor de índices de mínimos das linhas de~$B$, vale~$E[i] = B[i][R[i]]$ para toda linha~$i \in [2 \tdots n]$ de~$B$, portanto, resolver o Problema~\ref{Online:prob} é encontrar os índices de mínimos das linhas de~$B$.É interessante notar que a linha 1 de uma matriz triangular inferior não possui mínimo, já que todos os seus valores são indefinidos.

Como já dito, vamos discutir maneiras eficientes encontrar os índices ótimos de uma matriz online nas linhas e triangular inferior no caso onde essa matriz é totalmente monótona nas linhas. No Problema~\ref{Online:prob} é fácil aplicar o Lema~\ref{Monge:theo+1} para perceber que se a matriz~$C$ é Monge, a matriz~$B$ é Monge no mesmo sentido e, portanto, totalmente monótona. Assim, as técnicas discutidas nesta seção são suficientes para resolver o Problema~\ref{Online:prob}.

Passamos discutir agora o problema de encontrar os mínimos das linhas de uma matriz~$A \in \B{Q}^{n \times n}$ totalmente monótona nas linhas, online nas linhas e triangular inferior. É fácil adaptar as técnicas e formulações apresentadas para problemas de maximização e para o caso onde estamos interessados nos pontos ótimos das colunas de uma matriz totalmente monótona nas colunas e online nas colunas.

Para resolver este problema, usaremos uma estrutura de dados que chamamos de envelope.

\begin{defi}
Um envelope~$\Cl{E}$ sobre uma matriz~$A$ é uma estrutura de dados que mantém um conjunto de colunas~$J$ da matriz e é capaz de responder às seguintes operações:

\begin{description}
    \item[\textsc{Insere}($\Cl{E}$,$j$)] Insere uma coluna~$j$ disponível da matriz na estrutura de dados e
    \item[\textsc{Calcula}($\Cl{E}$,$i$)] Retorna~$\min\{j \in J \mid A[i][j] \leq A[i][j'] \text{ para todo } j' \in J\}$ onde~$i \in [n]$ e~$J$ é não vazio.
\end{description}
\end{defi}

Com esta definição, vamos descrever genericamente o Algoritmo~\ref{Online:algo} que retorna o vetor~$E$ de mínimos das linhas da matriz~$A$.

\begin{algorithm}[h]
\caption{Mínimos de linhas online}
\label{Online:algo}
\begin{algorithmic}[1]
\Function{Online}{A, n}
    \State $\Cl{E}$ é um envelope sobre a matriz~$B$
    \State $\textsc{Insere}(\Cl{E},1)$

    \For{$i$ de $2$ até $n$} \label{Online:algo:loop}
        \State $R[i] = \textsc{Calcula}(\Cl{E},i)$
        \State $\textsc{Insere}(\Cl{E},i)$
    \EndFor

    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}

O algoritmo acima funciona pois em toda iteração do laço da linha~\ref{Online:algo:loop}, a variável~$R[i]$ recebe o valor~$\min\{ j < i \mid B[i][j] \leq B[i][j'] \text{ para todo } j' < i\}$, que é o índice de mínimo da linha~$i$, portanto, o algoritmo retorna o vetor de índices de mínimos de~$A$.

Falta agora descrever a estrutura de envelope tanto para o caso côncavo quanto para o caso convexo. Nos dois casos temos a garantia de que o parâmetros passados tanto para \textsc{Insere} quanto para \textsc{Calcula} são dados em ordem crescente, isto é, as colunas são inseridas em ordem crescente de índice na estrutura e os mínimos das linhas também são calculados em ordem crescente. Inicialmente, nas Subseções~\ref{Online:convex} e~\ref{Online:concave} aproveitaremos apenas a propriedade descrita para a operação \textsc{Insere} e depois, na Subseção~\ref{Online:linear} utilizaremos também a propriedade descrita para \textsc{Calcula}.

%------------------------------------------------------------------

\subsection{Caso convexo} \label{Online:convex}
Discutiremos agora a implementação de um envelope~$\Cl{E}$ sobre uma matriz~$A$ totalmente monótona convexa nas linhas e online nas linhas. 

\begin{defi}[Coluna válida]
Uma coluna~$j \in J$ é válida somente se existe uma linha~$i \in [n]$ para a qual~${j = \textsc{Calcula}(\Cl{E},i)}$, ou seja, ela é o mínimo de alguma linha. Uma coluna que não respeita esta propriedade é chamada inválida.
\end{defi}

Se~$a$ e~$b$ são duas colunas de~$A$ onde~$a < b$, pela convexidade de~$A$ e pelo Lema~\ref{lema:MonotoneTotallyMonotone}, sabemos que a coluna~$a$ tem valor menor ou igual do que o da~$b$ para um prefixo potencialmente vazio das linhas e maior para o restante, um sufixo também potencialmente vazio, isto é, existe um índice~$i \in [n+1]$ tal que a partir da linha~$i$ a coluna~$b$ é a melhor entre as duas e antes da linha~$i$ a coluna~$a$ é a melhor. Definimos a operação~$\textsc{Intersecta}(a,b)$ que devolve este índice de linha. Formalmente, definimos~${\textsc{Intersecta}(a,b) = \min(\{ i \in [n] \mid A[i][a] > A[i][b] \} \cup \{n+1\})}$. O cálculo desta operação pode ser realizado com busca binária em tempo~$\Cl{O}(\lg(n))$ da maneira descrita no Algoritmo~\ref{Online:convex:BB}.

\begin{algorithm}[h]
\caption{Intersecção de duas colunas no caso convexo}
\label{Online:convex:BB}
\begin{algorithmic}[1]
\Function{Intersecta}{a,b}
    \State $\ell \rec 1$
    \State $r \rec n+1$

    \While{ $\ell < r$}
        \State $p \rec (\ell + r)/2$
        \If{ $A[p][a] > A[p][b]$} \label{Online:convex:BB:ineq}
            \State $r \rec p$
        \Else
            \State $\ell \rec p+1$
        \EndIf
    \EndWhile
    \State \Return $\ell$
\EndFunction
\end{algorithmic}
\end{algorithm}

Para cada coluna~$j \in J$ é interessante descobrir a primeira linha onde~$j$ é a coluna de menor valor dentre todas as colunas de índice menor do que ela em~$J$. Vamos definir este valor como~$s(j)$. Se~$j$ for maior ou igual a todas as colunas de índice menor em~$J$ para todas as linhas da matriz definimos~$s(j) = n+1$. Formalmente~${ s(j) = \min(\{i \in [n] \mid A[i][j] < A[i][j'] \text{ para todo } j' \in J \text{ tal que } j' < j\} \cup \{n+1\}) }$. Perceba que, pela total monotonicidade de~$A$, a coluna~$j$ tem valor menor ou igual a todas as de índice menor em~$J$ para toda linha a partir de~$s(j)$.

\begin{prop} \label{Online:convex:easys}
Para qualquer conjunto~$J$ de colunas de~$A$ e qualquer~$j \in J$ válido ou o conjunto~${\{j' \in J \mid j' \text{ é valido e } j' < j\}}$ é vazio e~$s(j) = 1$ ou~$\{s(j) = \textsc{Intersecta}(j^*,j)\}$ onde~$j^*$ é o máximo deste conjunto.

Isto é, para calcular o valor de~$s(j)$ basta escolher o maior~$j^* \in J$ válido de índice menor do que~$j$. Se tal~$j^*$ existe basta calcular sua intersecção com~$j$ e, caso contrário, definir~$s(j) = 1$.
\end{prop}

\begin{proof}
Sabemos que~$j$ é válida e, por este motivo, a linha~$s(j)$ pertence à matriz e tem~$j$ como sua coluna ótima. Sabemos, graças à total monotonicidade de~$A$, que se uma coluna~$j' \in J$ tem índice maior do que~$j$ ela só pode ser ótima em linhas maiores do que~$s(j)$ e, similarmente, se~$j'$ tem índice menor do que~$j$ só pode ser ótima em linhas de índice menor do que~$s(j)$. Com isso, se não há nenhuma coluna válida em~$J$ de índice menor do que~$j$ a coluna~$j$ deve ser a ótima em todas as linhas menores do que~$s(j)$ o que é contradiz a definição de~$s(j)$, portanto,~$s(j) = 1$, já que não pode haver uma linha menor do que~$s(j)$ e 1 é o único valor que respeita isso.

Por outro lado, se existe uma coluna em~$j$ válida de índice menor do que~$J$ chamamos de~$j^*$ a de maior índice dentre todas estas colunas. Se~$j^*$ não for a coluna ótima em~$s(j) - 1$ existe uma outra coluna~$j' \in J$ de índice menor do que~$j^*$ que é ótima na linha~$s(j) - 1$, isso se deve aos fatos de que a coluna ótima na linha~$s(j) - 1$ não pode ter índice maior do que~$j$, deve ser válida e não ter índice em~$[j^* \tdots j]$. Porém se~$j'$ for ótima em~$s(j) - 1$ ela é, pela total monotonicidade, menor do que~$j^*$ em todas as linhas de~$[1 \tdots s(j)-1]$, o que faz com que~$j^*$ seja inválida, um absurdo já que~$j^*$ é maior do que~$j$ em todas as linhas restantes, um absurdo. Assim,~$j^*$ é a coluna ótima em~$s(j) - 1$ e~$\textsc{Intersecta}(j^*,j) = s(j)$.
\end{proof}

A Proposição~\ref{Online:convex:easys} dá motivo a uma representação do envelope~$\Cl{E}$ que guarda todos os elementos válidos de~$J$ numa lista ordenada crescentemente. Nesta representação, calcular o~$s(j)$ de um dado~$j$ é fácil. Se~$j$ for o primeiro elemento,~$s(j) = 1$, caso contrário, basta visitar o elemento que precede~$j$ e calcular sua intersecção com~$j$. Vamos utilizar esta representação de~$\Cl{E}$. Além disso, guardaremos para cada elemento~$j$ da lista qual é o seu valor~$s(j)$. A nossa estrutura deve, então, manter 3 invariantes. Um valor~$j \in J$ pertence à estrutura se e somente se é válido, os valores aparecem em ordem crescente e todos os~$s(j)$ estão calculados corretamente.

\begin{algorithm}[h]
\caption{Envelope convexo}
\label{Online:envelope:convex}
\begin{algorithmic}[1]
\Function{Calcula}{\Cl{E},i}
    \State $\ell \rec 1$
    \State $r \rec |\Cl{E}|$
    
    \While{ $\ell < r$ }
        \State $p = (\ell+r)/2$
        \If{ $s(\Cl{E}_p) \leq i$ }
            \State $r = p$
        \Else
            \State $\ell = p+1$
        \EndIf
    \EndWhile

    \State \Return $\ell$
\EndFunction

\Function{Insere}{\Cl{E},j}
    \If{ $\Cl{E}$ é não vazio e~$A[n][\Cl{E}_{-1}] \leq A[n][j]$ }
        \State \Return
    \EndIf
    
    \While{ $\Cl{E}$ é não vazio e~$A[s(\Cl{E}_{-1})][\Cl{E}_{-1}] > A[s(\Cl{E}_{-1})][j]$ }
        \State Remove o final de~$\Cl{E}$
    \EndWhile

    \State Insere~$j$ ao final de~$\Cl{E}$
\EndFunction
\end{algorithmic}
\end{algorithm}

O Algoritmo~\ref{Online:envelope:convex} implementa as operações~\textsc{Calcula} e~\textsc{Insere} como descrito a seguir. Para responder a uma pergunta da forma~$\textsc{Insere}(\Cl{E},j)$ vamos aproveitar a garantia já citada de que~$j > j'$ para todo~$j' \in J$, isto é, as operações de inserção estão ordenadas crescentemente. É possível que~$j$ seja uma coluna inválida em~$J$, esta condição pode ser testada comparando os valores das coluna~$j$ com o valor da última coluna~$\Cl{E}_{-1}$ da estrutura, se~${A[n][\Cl{E}_{-1}] \leq A[n][j]}$, pela total monotonicidade,~$j$ será inválida, caso contrário~$j$ será a coluna ótima da estrutura na linha~$n$. No caso onde~$j$ é inválida, devemos ignorar esta operação de inserção, portanto, podemos assumir sem perda de generalidade que~$j$ é válida.

Devemos verificar se a nova coluna~$j$ torna alguma outra coluna de~$J$ inválida e remover esta coluna. Escolhemos a última coluna~$\Cl{E}_{-1}$ da estrutura e verificamos~${A[s(\Cl{E}_{-1})][\Cl{E}_{-1}] \leq A[s(\Cl{E}_{-1})][j]}$, se esta condição for verdade~$\Cl{E}_{-1}$ é válida pois é ótima no ponto~$s(\Cl{E}_{-1})$ e todas as colunas anteriores também são, já que, pela total monotonicidade, o valor da coluna~$\Cl{E}_{-1}$ supera o valor de~$j$ em todas as linhas anteriores a~$s(\Cl{E}_{-1})$, mantendo a validade de todos os elementos que possuem algum ponto ótimo em alguma dessas linhas. Se a condição for mentira, pela total monotonicidade,~$\Cl{E}_{-1}$ é superada por~$j$ de~$s(\Cl{E}_{-1})$ em diante e por alguma outra coluna antes desta linha, portanto, é inválida e deve ser removida, portanto, removemos~$\Cl{E}_{-1}$ e repetimos o processo até não haver mais elementos na lista ou até o último elemento ser válido. Com este trabalho, mantivemos a invariante de que todas as colunas de~$\Cl{E}$ são válidas.

Falta atualizar os valores~$s(j')$ para todo~$j' \in \Cl{E}$. Temos a garantia de que inserimos e removemos elementos apenas no final da lista, já que os valores~$s(j')$ dependem do elemento anterior, basta calcular o valor~$s(j)$ do novo elemento adicionado, o que sabemos fazer em tempo~$\Cl{O}(\lg(n))$. Isso garante a invariante de que os valores da função~$s$ estão guardados corretamente. A invariante de que o vetor é ordenado é trivialmente mantida já que só adicionamos elementos no final da lista.

Agora precisamos usar esta estrutura para responder rapidamente a uma pergunta da forma~${ \textsc{Calcula}(\Cl{E},i) }$ com~$i \in [n]$. Para isso, vamos descobrir o maior elemento~$j \in \Cl{E}$ tal que~$s(j) \leq i$. Este valor é a resposta correta pois a resposta deve ser válida, portanto, pertencer a~$\Cl{E}$ e~$j$ supera todos os elementos anteriores a ele a partir de~$s(j)$ e todo elemento~$j'$ seguinte antes de~$s(j')$ que, por construção, é maior do que~$i$. A tarefa de encontrar este~$j$ pode ser realizada com uma busca binária na lista~$\Cl{E}$.

Assumimos que a nossa implementação da lista~$\Cl{E}$ é capaz de visitar um elemento em uma dada posição em tempo~$\Cl{O}(1)$ além de adicionar e remover elementos do final da lista, isso, em \texttt{C++}, pode ser implementado utilizando a estrutura~\texttt{vector} da biblioteca padrão. Podemos criar uma estrutura que guarda tanto o valor~$j$ quanto o~$s(j)$ correspondente e montar nossa lista fazendo com que cada elemento seja um objeto deste tipo, com isso, acessar ou atualizar o~$s(j)$ de um~$j$ é equivalente a acessar o valor de~$j$. Uma implementação em~\texttt{C++} que respeita estas hipóteses pode ser encontrada em~\texttt{envelope\_convex}. Vamos calcular a complexidade dos algoritmos sugeridos.

Cada operação~\textsc{Calcula} envolve apenas uma busca binária na lista~$\Cl{E}$ onde cada iteração custa tempo constante, já que esta lista tem tamanho no máximo~$n$ (pois~$A$ tem~$n$ colunas), estas chamadas custam~$\Cl{O}(\lg(n))$ cada. Uma operação~\textsc{Insere} pode remover vários elementos de~$\Cl{E}$, custando tempo potencialmente linear, porém, cada elemento de~$\Cl{E}$ só pode ser removido uma única vez, fazendo com que a soma de todas as remoções custe tempo~$\Cl{O}(n)$. Além disso, esta operação insere um novo elemento em~$\Cl{O}(1)$ e calcula o valor~$s$ do novo elemento em tempo~$\Cl{O}(\lg(n))$, desta maneira, cada operação custa tempo~$\Cl{O}(\lg(n))$ amortizado.

%------------------------------------------------------------------

\subsection{Caso côncavo} \label{Online:concave}

Discutiremos agora a implementação do envelope~$\Cl{E}$ sobre uma matriz~$A$ totalmente monótona côncava nas linhas e online nas linhas. Este caso se desenvolve de maneira extremamente similar ao caso convexo, portanto, aproveitaremos várias das definições do caso convexo.

Se~$a$ e~$b$ são colunas válidas de~$A$ onde~$a < b$, pela concavidade de~$A$ e pelo Lema~\ref{lema:MonotoneTotallyMonotone}, sabemos que a coluna~$a$ tem valor \textbf{maior} do que o da~$b$ para um prefixo das linhas e menor ou igual para o restante (um sufixo). Definimos a operação~$\textsc{Intersecta}(a,b)$ que retorna o primeiro índice de linha para o qual~$a$ tem valor menor ou igual a~$b$. Formalmente, vale~${\textsc{Intersecta}(a,b) = \min\{i \in [n] \mid A[i][a] \leq A[i][b]\}}$. Podemos calcular este valor, também, com busca binária, de forma parecida com o Algoritmo~\ref{Online:convex:BB} com a alteração de que a linha~\ref{Online:convex:BB:ineq} deve checar a condição~$A[p][a] \leq A[p][b]$.

Para cada coluna~$j \in J$ estamos interessados agora em descobrir a primeira linha onde esta \textbf{não} é a de menor valor dentre todas as colunas de índice menor do que ela em~$J$. Vamos definir este valor como~$s(j)$. Se~$j$ possuir valor menor do que todas as colunas de~$J$ com índice menor, definimos~$s(j) = n+1$. Formalmente~$ {s(j) = \min(\{ i \in [n] \mid A[i][j] \geq A[i][j'] \text{ para algum } j > j' \in J \} \cup \{n+1\})} $. Perceba que, pela total monotonicidade, a coluna~$j$ terá valor menor do que todas as de índice menor para toda linha anterior a~$s(j)$ e haverá uma outra de valor menor ou igual a ela à partir desta linha.

\begin{prop} \label{Online:concave:easys}
Para qualquer conjunto~$J$ de colunas de~$A$ e qualquer~$j \in J$ válido ou o conjunto~${\{j' \in J \mid j' \text{ é vaido e } j' < j\}}$ é vazio e~$s(j) = n+1$ ou~${\{s(j) = \textsc{Intersecta}(j^*,j)\}}$ onde~$j^*$ é o máximo deste conjunto.
\end{prop}

\begin{proof}
A prova vai pelas mesmas linhas da prova da Proposição~\ref{Online:convex:easys}. Sabemos que~$s(j)$ é válida e, portanto, é ótima em pelo menos uma linha~$s(j) - 1$ e~$s(j) > 1$. Sabemos, graças à total monotonicidade de~$A$ que se uma coluna~$j' \in J$ tem índice maior do que~$j$ ela só pode ser ótima em linhas menores do que~$s(j)$ e, similarmente, se~$j'$ tem índice menor do que~$j$ ela só pode ser ótima em linhas de índice maior do que~$j$. Com isso, se não há nenhuma coluna válida em~$J$ de índice menor do que~$j$ a coluna~$j$ deve ser a ótima em todas as colunas de~$s(j)$ em diante, o que contraria a definição de~$s(j)$ quando~$s(j) < n+1$, portanto, a única escolha possível para~$s(j)$ é~$n+1$.

Por outro lado, se existe uma coluna em~$j$ válida de índice menor do que~$J$ chamamos de~$j^*$ a de maior índice dentre todas estas. Se~$j^*$ não for a coluna ótima em~$s(j)$ existe uma outra coluna~$j' \in J$ de índice menor do que~$j^*$ que é ótima na linha~$s(j)$, isso se deve aos fatos de que a coluna ótima na linha~$s(j)$ não pode ter índice maior do que~$j$, deve ser válida e não ter índice em~$[j^* \tdots j]$. Porém se~$j'$ for ótima em~$s(j)$ ela é, pela total monotonicidade, menor do que~$j^*$ em todas as linhas de~$[s(j) \tdots n]$, o que faz com que~$j^*$ seja inválida já que~$j^*$ é maior do que~$j$ em todas as linhas restantes, um absurdo. Assim,~$j^*$ é a coluna ótima em~$s(j)$ e~$\textsc{Intersecta}(j^*,j) = s(j)$.
\end{proof}

Novamente, a Proposição~\ref{Online:concave:easys} indica uma representação do envelope~$\Cl{E}$ que guarda todos os elementos válidos de~$J$ numa lista ordenada crescentemente. Para calcular~$s(j)$ basta olhar para o elemento que precede~$j$ na estrutura, se não houver um vale~$s(j) = n+1$, caso contrário~$s(j)$ é a intersecção destes dois elementos. Vamos utilizar esta representação para o envelope e, mais uma vez, guardar, para cada~$j$, o valor~$s(j)$. As operações serão realizadas de forma a manter as mesmas invariantes do caso convexo, isto é, um valor~$j \in J$ pertence à estrutura se e somente se é válido, os valores aparecem em ordem crescente e todos os~$s(j)$ estão calculados corretamente.

\begin{algorithm}[h]
\caption{Envelope côncavo}
\label{Online:envelope:concave}
\begin{algorithmic}[1]
\Function{Calcula}{\Cl{E},i}
    \State $\ell \rec 1$
    \State $r \rec |\Cl{E}|$
    
    \While{ $\ell < r$ }
        \State $p = (\ell+r+1)/2$
        \If{ $s(\Cl{E}_p) \leq i$ }
            \State $r = p - 1$
        \Else
            \State $\ell = p$
        \EndIf
    \EndWhile

    \State \Return $\ell$
\EndFunction

\Function{Insere}{\Cl{E},j}
    \If{ $\Cl{E}$ é não vazio e~$A[1][\Cl{E}_{-11}] \leq A[1][j]$ }
        \State \Return
    \EndIf
    
    \While{ $\Cl{E}$ é não vazio e~$A[s(\Cl{E}_{-1})-1][\Cl{E}_{-1}] > A[s(\Cl{E}_{-1})-1][j]$ }
        \State Remove o fim de~$\Cl{E}$
    \EndWhile

    \State Insere~$j$ no final de~$\Cl{E}$
\EndFunction
\end{algorithmic}
\end{algorithm}

O Algoritmo~\ref{Online:envelope:concave} implementa as operações~\textsc{Calcula} e~\textsc{Insere} como descrito a seguir. Para responder a uma pergunta da forma~$\textsc{Insere}(\Cl{E},j)$ vamos aproveitar a garantia já citada de que~$j > j'$ para todo~$j' \in J$, isto é, as operações de inserção estão ordenadas crescentemente. Primeiro, verificamos se~$j$ é uma coluna inválida em~$J$, para tanto, basta comparar o valor da coluna~$j$ com o valor da coluna~$\Cl{E}_{-1}$ (caso esta exista) na primeira linha da matriz, já que a total monotonicidade garante que se~$j$ for menor do que~$\Cl{E}_{-1}$ em alguma linha, deverá ser na primeira. No caso onde~$j$ é inválida ignoramos esta operação, portanto, podemos assumir que~$j$ é válida daqui em diante.

Devemos verificar se a nova coluna~$j$ torna alguma outra coluna de~$J$ inválida e, caso faça, remover esta coluna. Escolhemos a primeira coluna~$\Cl{E}_{-1}$ da estrutura e verificamos se~$j$ é menor do que~$\Cl{E}_{-1}$ na última linha onde esta é ótima, isto é,~$s(\Cl{E}_{-1}) - 1$. Se isso for verdade, pela total monotonicidade,~$\Cl{E}_{-1}$ deixa de ser válida e deve ser removida, caso contrário, ela permanece válida por ser ótima pelo menos na linha~$s(\Cl{E}_{-1}) - 1$. No primeiro caso, removemos a primeira coluna da estrutura e repetimos o processo, já no segundo caso, pela total monotonicidade, nenhuma coluna de~$J$ se tornará inválida com a adição de~$j$, portanto, basta adicionar~$j$ ao fim da estrutura. Desta forma, mantivemos a invariante de que~$\Cl{E}$ contém todos e apenas valores que representam colunas válidas de~$J$.

Para atualizar os valores~$s(j')$ de todo valor~$j' \in \Cl{E}$ basta perceber, mais uma vez que estes não mudam, já que só inserimos e removemos elementos do final de~$\Cl{E}$ e cada um destes depende apenas do elemento que antecede ele na estrutura. Portanto, basta calcular o valor de~$s(j)$ para o elemento~$j$ recém adicionado em tempo~$\Cl{O}(\lg(n))$ garantindo a invariante de que todos os valores de~$s$ estão corretamente calculados. Além destas duas, a invariante de que o vetor é ordenado é trivialmente mantida.

Para responder a pergunta da forma~${ \textsc{Calcula}(\Cl{E},i) }$ com~$i \in [n]$ precisamos descobrir o maior valor~$j \in \Cl{E}$ tal que~$s(j) > i$ e, similarmente ao caso convexo, este valor pode ser encontrado com busca binária em tempo~$\Cl{O}(\lg(n))$. As mesmas hipóteses sobre acessos a elementos da estrutura realizadas no caso convexo são feitas aqui e é possível encontrar uma implementação que respeita estas hipóteses em~\texttt{envelope\_concave}. 

Vamos calcular a complexidade dos algoritmos sugeridos. Cada operação~\textsc{Calcula} custa tempo~$\Cl{O}(\lg(n))$, como já citado, e cada elemento de~$J$ só é inserido e removido pela operação~\textsc{Insere} no máximo uma vez, portanto, todas as inserções e remoções custam tempo~$\Cl{O}(1)$ amortizado, porém, esta operação deve calcular~$s(j)$ ao inserir um elemento~$j$, o que faz com que seu tempo final seja~$\Cl{O}(\lg(n))$ amortizado.

%------------------------------------------------------------------

\subsection{Envelopes em tempo linear} \label{Online:linear}

Um caso especial interessante deste problema é aquele onde matriz~$A$ é definida em termo de retas com coeficientes angulares ordenados, isto é, existem vetores~$a,b \in \B{Q}^n$ tais que~$a$ é monótona e~$A[i][j] = a_j*i + b_j$. É fácil provar que se~$a$ é decrescente,~$A$ é totalmente monótona convexa nas linhas e se~$a$ é crescente,~$A$ é totalmente monótona côncava nas colunas.

Este é um bom exemplo de caso para a qual a função~\textsc{Intersecta} pode ser calculada em tempo~$\Cl{O}(1)$. Galil e Park ao descrever os algoritmos discutidos aqui fazem com que a utilização deste fato se torne clara. Da forma como foram descritos aqui, é necessário fazer uma observação para atingir esta complexidade.

Durante o desenvolvimento do nosso método, não aproveitamos o fato de sabermos que as operações~\textsc{Calcula} serão chamadas com parâmetro crescente, isto é, as linhas para as quais deveremos descobrir o valor ótimo estarão ordenadas. Para utilizar este fato, vamos manter um ponteiro~$\ell$ para o último item da estrutura que foi resposta de alguma pergunta deste tipo ou para o primeiro item da estrutura, caso nenhuma pergunta tenha sido feita ainda. 

\begin{algorithm}[h]
\caption{Calcula no envelope convexo em tempo linear}
\label{Online:envelope:linear}
\begin{algorithmic}[1]
\Function{Calcula}{\Cl{E},i}
    \If{ $\ell$ aponta para um elemento fora de~$\Cl{E}$ }
        \State $\ell$ passa a apontar para~$\Cl{E}_1$
    \EndIf
    
    \While{ existe um~$r$ que sucede~$\ell$ e~$A[i][r] < A[i][\ell]$}
        \State $\ell \rec r$
    \EndWhile

    \State \Return valor de $\ell$
\EndFunction
\end{algorithmic}
\end{algorithm}

O Algoritmo~\ref{Online:envelope:linear} reimplementa a operação em questão no caso convexo mostrando como utilizar este ponteiro para responder às perguntas mais eficientemente. Se o ponteiro aponta para alguém fora da estrutura, ele é mandado novamente para o início, se o elemento atual é menor do que o seguinte na linha atual, ele é o ótimo, caso contrário, o ponteiro é movido para o próximo elemento e o algoritmo recomeça. Este algoritmo leva tempo constante amortizado já que o ponteiro só passa a apontar para cada elemento uma única vez, portanto, só pode ser movido no máximo~$n$ vezes.

%------------------------------------------------------------------

\subsection{Relação com Pareto}

O caso convexo funciona de maneira parecida como uma fronteira de Pareto em pares~$(j,s(j))$ que restringe a ordem das buscas e inserções e o caso côncavo pode ser interpretado, também, de maneira parecida. É razoável imaginar o motivo de não podermos realizar todas as operações de uma fronteira de Pareto no envelope. A próxima seção explora esta possibilidade.
