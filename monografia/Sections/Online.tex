\section{Busca em matrizes online}
\label{Online}

Nesta seção começamos a estudar formas de encontrar índices ótimos em matrizes onde certas entradas são desconhecidas à priori. Inicialmente o formato das matrizes abordadas será explicitado juntamente com um exemplo de um caso específico interessante desta técnica apresentado por Galil e Park~\cite{Galil:1992}. Na Seção~\ref{FullyDynamic} buscaremos generalizar a técnica apresentada aqui para outras matrizes online.

Para conseguir lidar com matrizes que não são inteiramente conhecidas à priori, devemos explicar quais dependências podem aparecer e quais não podem, para isso, é útil descrever matrizes online segundo a Definição~\ref{Online:matrix}.

\begin{defi}[Matriz online] \label{Online:matrix}
Dizemos que uma matriz~$A \in \B{Q}^{n \times n}$ com vetor de índices de mínimos de linhas~$R$ é online nas linhas se para todo~$i,j \in [n]$ com~$i \neq j$ o valor de~$A[i][i]$ é conhecido à priori e os valores de~$A[i][j]$ podem depender de~$R[j]$. Isto é, em uma matriz online, a diagonal é conhecida e as outras entradas de uma \textbf{coluna}~$j$ qualquer dependem do índice do mínimo da \textbf{linha}~$j$ correspondente.

Similarmente, dizemos que uma matriz é online nas colunas quando as entradas de suas diagonais são conhecidas à priori porém uma entrada~$A[i][j]$ fora da diagonal pode depender do índice de mínimo da coluna~$i$.
\end{defi}

Note que a definição permite que outras entradas além das diagonais sejam conhecidas à priori. Dizemos ainda que uma entrada da matriz está disponível se é possível descobrir seu valor, isto é, ela era conhecida à priori ou ela só depende de informações já calculadas.

Nesta seção exploraremos especificamente o caso onde a matriz é triangular inferior, isto é, cada entrada~$A[i][j]$ da matriz onde~$i \geq j$ é indefinida. Vamos descobrir métodos para encontrar índices ótimos nestas matrizes quando elas forem totalmente monótonas convexa ou côncavas. O Problema~\ref{Online:prob} ilustra a utilidade de trabalhar com matrizes deste tipo.

\begin{prob} \label{Online:prob}
Dada uma matriz de custos~$C \in \B{Q}^{n \times n}$, computar o vetor~$E$ tal que~$E[1] = 0$ e para todo~$i \in [1 \tdots n]$ vale~$E[i] = \min\limits_{j < i} C[i][j] + E[j]$.
\end{prob}

Com uma matriz~$C$ e um vetor~$E$ definidos como no Problema~\ref{Online:prob}, criamos a matriz~$B \in \B{Q}^{n \times n}$ de forma que para todo~$i,j \in [n]$ vale
\begin{equation} \label{Online:Bmat}
    B[i][j] = \begin{cases}
        \text{indefinida} & \text{, se } i \leq j \text{ e } \\
        C[i][j] + E[j]    & \text{, caso contrário.}
    \end{cases}
\end{equation}

Primeiramente, é fácil observar que a matriz~$B$ é online nas linhas e triangular inferior, além disso, se~$R$ é o vetor de índices de mínimos das linhas de~$B$, vale~$E[i] = B[i][R[i]]$ para toda linha~$i \in [2 \tdots n]$ de~$B$, portanto, resolver o Problema~\ref{Online:prob} é encontrar os índices de mínimos das linhas de~$B$.É interessante notar que a linha 1 de uma matriz triangular inferior não possui mínimo, já que todos os seus valores são indefinidos.

Como já dito, vamos discutir maneiras eficientes encontrar os índices ótimos de uma matriz online nas linhas e triangular inferior no caso onde essa matriz é totalmente monótona nas linhas. No Problema~\ref{Online:prob} é fácil aplicar o Lema~\ref{Monge:theo+1} para perceber que se a matriz~$C$ é Monge, a matriz~$B$ é Monge no mesmo sentido e, portanto, totalmente monótona. Assim, as técnicas discutidas nesta seção são suficientes para resolver o Problema~\ref{Online:prob}.

Passamos discutir agora o problema de encontrar os mínimos das linhas de uma matriz~$A \in \B{Q}^{n \times n}$ totalmente monótona nas linhas, online nas linhas e triangular inferior. É fácil adaptar as técnicas e formulações apresentadas para problemas de maximização e para o caso onde estamos interessados nos pontos ótimos das colunas de uma matriz totalmente monótona nas colunas e online nas colunas.

Para resolver este problema, usaremos uma estrutura de dados que chamamos de envelope.

\begin{defi}
Um envelope~$\Cl{E}$ sobre uma matriz~$A$ é uma estrutura de dados que mantém um conjunto de colunas~$J$ da matriz e é capaz de responder às seguintes operações:

\begin{description}
    \item[\textsc{Insere}($\Cl{E}$,$j$)] Insere uma coluna~$j$ disponível da matriz na estrutura de dados e
    \item[\textsc{Calcula}($\Cl{E}$,$i$)] Retorna~$\min\{j \in J \mid A[i][j] \leq A[i][j'] \text{ para todo } j' \in J\}$ onde~$i \in [n]$ e~$J$ é não vazio.
\end{description}
\end{defi}

Com esta definição, vamos descrever genericamente o Algoritmo~\ref{Online:algo} que retorna o vetor~$E$ de mínimos das linhas da matriz~$A$.

\begin{algorithm}[h]
\caption{Mínimos de linhas online}
\label{Online:algo}
\begin{algorithmic}[1]
\Function{Online}{A, n}
    \State $\Cl{E}$ é um envelope sobre a matriz~$B$
    \State $\textsc{Insere}(\Cl{E},1)$

    \For{$i$ de $2$ até $n$} \label{Online:algo:loop}
        \State $R[i] = \textsc{Calcula}(\Cl{E},i)$
        \State $\textsc{Insere}(\Cl{E},i)$
    \EndFor

    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}

O algoritmo acima funciona pois em toda iteração do laço da linha~\ref{Online:algo:loop}, a variável~$R[i]$ recebe o valor~$\min\{ j < i \mid B[i][j] \leq B[i][j'] \text{ para todo } j' < i\}$, que é o índice de mínimo da linha~$i$, portanto, o algoritmo retorna o vetor de índices de mínimos de~$A$.

Falta agora descrever a estrutura de envelope tanto para o caso côncavo quanto para o caso convexo. Nos dois casos temos a garantia de que o parâmetros passados tanto para \textsc{Insere} quanto para \textsc{Calcula} são dados em ordem crescente, isto é, as colunas são inseridas em ordem crescente de índice na estrutura e os mínimos das linhas também são calculados em ordem crescente.

%------------------------------------------------------------------

\subsection{Caso convexo}
Discutiremos agora a implementação de um envelope~$\Cl{E}$ sobre uma matriz~$A$ totalmente monótona convexa nas linhas e online nas linhas. 

Dadas duas colunas~$a,b \in [n]$ onde~$a < b$ definimos a operação~$\textsc{Intersecta}(a,b)$ que descobre a primeira linha da matriz para a qual o valor da coluna~$b$ é menor do que o valor da coluna~$a$ ou~$n+1$ se este índice não existir, isto é~${\textsc{Intersecta}(a,b) = \min\{\{ i \in [n] \mid A[i][a] > A[i][b] \} \cup \{n+1\}\}}$. Note que pelo Lema~\ref{MonotoneTotallyMonotone} os índices de mínimos das linhas são crescentes em toda submatriz de~$A$ e isso nos diz que a partir do ponto~$\textsc{Intersecta}(a,b)$ a coluna~$b$ tem valor menor do que a coluna~$a$. Note também que o calculo desta operação pode ser realizado em tempo~$\Cl{O}(n)$ com busca binária.

Para cada coluna~$j$ de~$A$ estamos interessados, também, no primeiro momento onde esta coluna é a de menor valor dentre todas as de índice menor já presentes na estrutura~$J$, para isso, definimos a função~${ s(j) = \max\{\{ \textsc{Intersecta}(j',j) \mid j' < j \text{ e } j' \in J \} \cup \{ 1 \} \} }$. Pela total monotonicidade de~$A$ é fácil perceber que a partir do ponto~$s(j)$ a coluna~$j$ é a menor dentre todas as em~$J$ de índice menor do que ela. 

Representaremos o envelope~$\Cl{E}$ com uma lista de pares~$(j,s(j))$ onde~$j \in J$ ordenada pelo valor de~$j$ e manter as invariantes de que os valores~$s(j)$ estão calculados corretamente e caso~$s(j) = n+1$ o par~$(j,s(j))$ foi removido da lista. O Algoritmo~\ref{Online:envelope:convex} implementa as operações~\textsc{Insere} e~\textsc{Calcula} sobre esta representação de envelope.

\begin{algorithm}[h]
\caption{Envelope convexo}
\label{Online:envelope:convex}
\begin{algorithmic}[1]
\Function{Calcula}{\Cl{E},i}
    \While{ $\Cl{E}$ tem pelo menos 2 elementos}
        \State $(j_2,s(j_2))$ é o segundo elemento
        \If{$s(j_2) \leq i$}
            \State Remove o primeiro elemento de~$\Cl{E}$
        \Else
            \State $(j_1,s(j_1))$ é o primeiro elemento
            \State \Return $j_0$
        \EndIf
    \EndWhile
    \State $(j_0,s(j_0))$ é o primeiro elemento
    \State \Return $j_0$
\EndFunction

\Function{Insere}{\Cl{E},j}
\EndFunction
\end{algorithmic}
\end{algorithm}

%------------------------------------------------------------------

\subsection{Caso côncavo}
