\section{Otimização de Knuth-Yao}
\label{KY}

%----------------------------------------------------------------------------------------

O problema da árvore de busca binária ótima~\cite{CLRS} é um exemplo clássico de aplicação de programação dinâmica sendo fácilmente resolvido em tempo~$\Cl{O}(n^3)$. Aproveitando algumas propriedades do problema, Knuth~\cite{Knuth:1971} mostrou que ele pode ser resolvido em tempo~$\Cl{O}(n^2)$ sem que se mude muito o pensamento por trás da solução trivial. 

Mais tarde, a solução apresentada por Knuth foi estudada por Yao~\cite{Yao:1980,Yao:1982} que relacionou a otimização realizada com o fato de que a recorrência utilizada para resolver o problema descrevia uma matriz Monge e, com isso, mostrou que várias outras recorrências poderiam ser agilizadas utilizando a mesma técnica.  

Após as descobertas de Yao, a otimização de Knuth foi utilizada para melhorar a solução de vários outros problemas em programação dinâmica. Bein, Golin, Larmore e Zhang~\cite{Bein:2009} buscaram enfraquecer a condição encontrada por Yao e mostraram que as matrizes descritas pelos problemas agilizados com a otimização Knuth-Yao podem ser decompostas de 3 maneiras diferentes em matrizes totalmente monótonas. Esta introdução foi baseada no artigo citado neste parágrafo.

%----------------------------------------------------------------------------------------

\subsection{Quebrando Strings}

Para explicar a técnica desenvolvida por Knuth. Iremos nos resolver um outro problema clássico de programação dinâmica~\cite[Exercício~15-9]{CLRS} disponível no juíz online SPOJ em \url{http://www.spoj.com/problems/BRKSTRNG/}. 

Considere uma linguagem de processamento de strings que consegue quebrar uma string~$s$ de tamanho~$n > 1$ em qualquer posição~$t \in [n-1]$, ou seja, gerar duas strings~$s[1 \tdots t]$ e~$s[t+1 \tdots n]$. Um programador quer usar este programa para separar uma string~$m-1$ vezes, nas posições~$p_1 < p_2 < \dots < p_{m-1}$, porém, para quebrar uma string de tamanho~$n$ em qualquer posição, a linguagem gasta tempo~$n$. Queremos descobrir qual é a melhor ordem de realizar estes cortes. 

Suponha, por exemplo, que estamos interessados em quebrar uma string de tamanho 26 nas posições 3, 14, poderíamos fazer isso de duas maneiras. Podemos quebrar e uma de 3 e outra de 23 e, depois disso, quebrar a de 23 em uma de 11 e outra de 12, o que custaria tempo 49, e podemos quebrar a inicial em uma de 14 e outra de 9, separando a de 14 em uma de 3 e outra de 11 após a primeira operação, nos dando uma solução de tempo 30, que é a solução ótima. Vamos resolver o problema de encontrar a ordem ótima para este particionamento com programação dinâmica.

Supomos que nos são dados os valores~$n$,~$m$ e os pontos~$p_1 < p_2 < \dots < p_{m-1}$ dos cortes desejados. Chamamos de~$s$ a string que desejamos separar, note que o conteúdo da string é irrelevante para a solução do problema. Definimos~$p_0 = 0$ e~$p_m = n$ e a matriz~$A$ por uma recorrência que nos dá, em toda entrada~$i<j$ o tempo ótimo para resolver o subproblema que recebe como entrada a string~$s[p_i + 1 \tdots p_j]$ e só realiza os cortes pertencentes a esta string, desta forma, a entrada~$A[0][m]$ nos dá a solução ótima para o nosso subproblema. 

\begin{equation*}
A[i][j] = \begin{cases}
    +\infty                                                     & \text{, se } i \geq j \text{,} \\
    0                                                           & \text{, se } i + 1 = j \text{ e } \\
    p_j - p_i + 1 + \min\limits_{i < k < j} (A[i][k] + A[k][j]) & \text{, caso contrário. }
\end{cases}
\end{equation*}

É fácil resolver o problema descrito em tempo~$\Cl{O}(m^3)$. Vamos melhorar a solução para um tempo~$\Cl{O}(m^2)$.

%----------------------------------------------------------------------------------------

%\subsection{
