\section{Divisão e Conquista}
\label{DivisaoEConquista}

%----------------------------------------------------------------------------------------

Nesta seção será apresentada uma técnica que chamamos de Divisão e Conquista. A ideia é brevemente citada em~\cite{needed} e é um tópico recorrente em competições de programação, sendo conhecida como ``Divide and Conquer Optimization''~\cite{needed} e geralmente aplicada a problemas de programação dinâmica. Além disso, as hipóteses deste algoritmo são mais fracas do que as do algoritmo SMAWK, apresentado na Seção~\ref{SMAWK}, portanto, todo problema para o qual aquela solução pode ser aplicada, esta também pode. Ao final desta seção, apresentamos exemplos de aplicações em programação dinâmica.  

Dada uma matriz $A \in \B{Q}^{n \times m}$, listamos os casos de uso deste algoritmo:
\begin{itemize}
    \item Se $A$ é monótona crescente nos mínimos das linhas podemos encontrar os índices de mínimos das linhas em tempo $\Cl{O}((n+m)\lg(n))$, 
    \item se $A$ é monótona decrescente nos mínimos das linhas podemos encontrar os índices de mínimos das linhas em tempo $\Cl{O}((n+m)\lg(n))$, 
    \item se $A$ é monótona crescente nos máximos das linhas podemos encontrar os índices de máximos das linhas em tempo $\Cl{O}((n+m)\lg(n))$, 
    \item se $A$ é monótona decrescente nos máximos das linhas podemos encontrar os índices de máximos das linhas em tempo $\Cl{O}((n+m)\lg(n))$, 
    \item se $A$ é monótona crescente nos mínimos das colunas podemos encontrar os índices de mínimos das colunas em tempo $\Cl{O}((n+m)\lg(m))$, 
    \item se $A$ é monótona decrescente nos mínimos das colunas podemos encontrar os índices de mínimos das colunas em tempo $\Cl{O}((n+m)\lg(m))$, 
    \item se $A$ é monótona crescente nos máximos das colunas podemos encontrar os índices de máximos das colunas em tempo $\Cl{O}((n+m)\lg(m))$ e 
    \item se $A$ é monótona decrescente nos máximos das colunas podemos encontrar os índices de máximos das colunas em tempo $\Cl{O}((n+m)\lg(m))$.
\end{itemize}

Apresentaremos o caso em que $A$ é crescente nos mínimos das linhas. Na Subseção~\ref{DivisaoEConquista_Generalizacoes} explicamos como reduzir os problemas elencados para este caso.

%----------------------------------------------------------------------------------------

\subsection{Técnica}
Dada uma matriz $A \in \B{Q}^{n \times m}$ monótona crescente nos máximos das linhas, queremos encontrar o vetor de índices de máximos das linhas de $A$. Isto é, para todo $i \in [n]$, queremos encontrar
$$ R[i] = \min\{j \mid A[i][j] \geq A[i][j'] \text{ para todo } j' \in [n]\} \text{.}$$  

Se, para alguma linha $i$, encontrarmos o valor $R[i]$, sabemos, já que $A$ é monótona convexa, que para todo $i' < i$, $R[i'] \leq R[i]$ e, para todo $i' > i$, $R[i'] \geq R[i]$, isto é, sabemos que os máximos de menor índice das outras linhas se encontram nas submatrizes $A[1 \tdots i-1][1 \tdots R[i]]$ e $A[i+1 \tdots n][R[i] \tdots m]$. Basta, agora, seguindo o paradigma de divisão e conquista, resolver o mesmo problema para estas submatrizes e conseguimos resolver o problema original. 

\newcommand{\FRMDC}{\textsc{FindRowMax\_DC}}
\begin{algorithm}[H]
\caption{Máximos das linhas com divisão e conquista}
\label{FindRowMax_DC}
\begin{algorithmic}[1]
\Function{\FRMDC}{A, r_s, r_t, c_s, c_t}
    \State $\ell \rec \ceil{(r_s+r_t)/2}$
    \State $R[\ell] \rec \min\{j \mid A[i][j] \geq A[i][j'] \text{ para todo } j' \in [c_s \tdots c_t]\}$
    \If{$i > r_s$}
        \State $R[r_s \tdots \ell-1] \rec \FRMDC(A, r_s, \ell-1, c_s, R[\ell])$ \label{FindRowMax_DC:Div_left}
    \EndIf
    \If{$i < r_t$}
        \State $R[\ell+1 \tdots r_t] \rec \FRMDC(A, \ell+1, r_t, R[\ell], c_t)$ \label{FindRowMax_DC:Div_right}
    \EndIf
    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Análise}
Será feita uma análise do tempo de execução do algoritmo acima no pior caso assumindo que as atribuições feitas nas linhas~\ref{FindRowMax_DC:Div_left} e~\ref{FindRowMax_DC:Div_right} custam tempo constante, futuramente, em \ref{DivisaoEConquista_Implementacao}, iremos apresentar uma implementação em C++ que está de acordo com a análise realizada.  

Se $A$ é uma matriz e $r_s,r_t,c_s$ e $c_t$ são índices tais que $r_t-r_s = n > 0$ e $c_t-c_s = m > 0$, o tempo gasto por $\FRMDC(A,r_s,r_t,c_s,c_t)$ pode ser expresso pela seguinte recorrência:
\begin{equation*}
\arraycolsep=2pt
T(n,m) = \left\{
\begin{array}{lllll}
    m &   &                         &                         & \text{, se } n = 1 \text{,} \\
    m & + & \max\limits_{j \in [m]} & T(1,j)                  & \text{, se } n = 2 \text{,} \\[2pt]
    m & + & \max\limits_{j \in [m]} & \left\{\begin{array}{c}
     T(\ceil{n/2}-1,m-j+1) \\
     + T(\floor{n/2},j)    \\
    \end{array} \right\}                                      & \text{, caso contrário.} \\
\end{array}
\right.
\end{equation*}

\begin{prop}
Para todo $n,m \geq 1$, $T(n,m) \leq (m+n)\lg(2n)$ e, portanto, a técnica da divisão e conquista consegue encontrar o máximo de todas as linhas em tempo $\Cl{O}((m+n)\lg(n))$
\end{prop}

\begin{proof}
Vamos usar indução em $n$ para provar a tese. Se $n = 1$ e $m \geq 1$, $T(1,m) = m \leq (m+1)\lg(2)$. Se $n = 2$ e $m \geq 1$, existe $j \in [m]$ tal que $T(2,m) = m + r \leq 2m \leq (m+2)\lg(4)$. Agora, se $n \geq 3$ e $m \geq 1$, existe um $j \in [m]$ tal que 
$$ T(n,m) = m + T(\ceil{n/2} - 1, j) + T(\floor{n/2}, m - j + 1). $$
Assumimos para $1 \leq n' < n$ e $m' \geq 1$ que $T(n',m') \leq (m'+n')\lg(2n')$. Com isso, já que $1 \leq \ceil{n/2}-1 < n$, $1 \leq \floor{n/2} < n$, $j \geq 1$ e $m - j + 1 \geq 1$, temos, com a equação acima e o fato de que $\ceil{n/2}-1 \leq \floor{n/2} \leq n/2$,
\begin{eqnarray*} 
    T(n,m) & \leq & m + (j + \ceil{n/2} - 1 + m - j + 1 + \floor{n/2})\lg(n) \\
           & =    & m + (m + n)\lg(n) < (m + n)(\lg(n) + 1) = (m + n)\lg(2n).
\end{eqnarray*}
\end{proof}

\subsection{Implementação} \label{DivisaoEConquista_Implementacao}
Para implementar o Algoritmo~\ref{FindRowMax_DC} com a complexidade desejada, devemos tomar cuidado com as atribuições feitas nas linhas~\ref{FindRowMax_DC:Div_left} e~\ref{FindRowMax_DC:Div_right}. A forma como elas foram apresentadas sugere que os vetores $R$ recebidos pelas funções sejam recebidos e copiados para o vetor $R$. Ao invés de fazer isso, passaremos o endereço do vetor $R$ recursivamente e garantir que cada chamada só complete o subvetor $R[r_c \tdots r_t]$, referente a seu subproblema. Além disso, como explicado na Seção~\ref{Introducao_Implementacao}, a matriz $A$ será passada como uma função e não como uma matriz.

A implementação em C++ do algoritmo apresentado, levando em conta as considerações acima, pode ser encontrada em \texttt{implementacao/FindRowMax\_DC.cpp}.

\subsection{Generalizações} \label{DivisaoEConquista_Generalizacoes}
\todo[inline]{Isso é chato de ser escrito, não basta transformar a matriz e usar as coisas como caixa preta por causa da forma como índices de máximos e mínimos foram definidos}
