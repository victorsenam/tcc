\section{Divisão e Conquista}
\label{DivisaoEConquista}

%----------------------------------------------------------------------------------------

Aqui será apresentada uma técnica que pode ser usada para encontrar máximos ou mínimos de linhas em matrizes monótonas convexas\todo{eu acho que tem que falar algo como "monótona convexa por linhas". Eu quero dizer que o row-maxima tem índice crescente no índice da linha. Quando estiver escrevedo a seção 2 vou pensar melhor sobre isso.} ou côncavas em tempo $O((m+n)\lg(n))$, onde $m$ é a quantidade de colunas e $n$ a quantidade de linhas da matriz. Ao final, apresentamos exemplos de aplicações desta ideia em programação dinâmica.  

%----------------------------------------------------------------------------------------

\subsection{Técnica}
Dada uma matriz $A \in \B{Q}^{n \times m}$ monótona convexa, queremos encontrar, para toda linha $i$ da matriz, o menor índice $j$ tal que $A[i][j]$ é o valor máximo da linha $i$. Formalmente, queremos encontrar o vetor $R \in \B{N}^n$ onde, para todo $i \in [n]$,
$$ R[i] = \min\{j \mid A[i][j] \geq A[i][j'] \text{ para todo } j' \in [n]\} \text{.}$$  

Se, para alguma linha $i$, encontrarmos o valor $R[i]$, sabemos, já que $A$ é monótona convexa, que para todo $i' < i$, $R[i'] \leq R[i]$ e, para todo $i' > i$, $R[i'] \geq R[i]$, isto é, sabemos que os máximos de menor índice das outras linhas se encontram nas submatrizes $A[1 \tdots i-1][1\tdots R[i]]$ e $A[i+1\tdots n][R[i]\tdots m]$. Basta, agora, resolver o mesmo problema para estas submatrizes e conseguimos resolver o problema original. 

\begin{algorithm}[H]
\caption{Máximo de linhas com divisão e conquista}
\label{DivideAndConquer}
\begin{algorithmic}[1]
\Function{DivConq}{A}
    \State $n \rec \text{quantidade de linhas de } A$ 
    \State $m \rec \text{quantidade de colunas de } A$ 
    \State $i \rec \ceil{n/2}$
    \State $R[i] \rec \min\{j \mid A[i][j] \geq A[i][j'] \text{ para todo } j' \in [n]\}$
    \If{$i > 1$}
        \State $R[1 \tdots i-1] \rec \textsc{DivConq}(A[1 \tdots i-1][1 \tdots R[i]])$           \label{DivideAndConquer:Div_left}
    \EndIf
    \If{$i < n$}
        \State $R[i+1 \tdots n] \rec R[i] + \textsc{DivConq}(A[i+1 \tdots n][R[i] \tdots m])$    \label{DivideAndConquer:Div_right}
    \EndIf
    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Análise}
Será feita uma análise do tempo de execução do algoritmo acima assumindo que as atribuições feitas nas linhas \ref{DivideAndConquer:Div_left} e \ref{DivideAndConquer:Div_right} custam tempo constante, futuramente, em \ref{DivisaoEConquista_Implementacao}, iremos apresentar uma implementação em C++ que está de acordo com a análise realizada.  

Se $A \in \B{Q}^{n \times m}$, o tempo gasto por $\textsc{FindRowMax\_DivConq}(A)$ pode ser expresso pela seguinte recorrência:
\begin{equation*}
T(n,m) =
\begin{cases}
    m                                           & \text{, se } n = 1 \text{,} \\
    m + T(1,r) \text{ para algum } r \in [m]    & \text{, se } n = 2 \text{,} \\[2pt]
    \begin{array}{lll}
        m & + & T(\ceil{n/2}-1,m-r+1) \\
          & + & T(\floor{n/2},r) \text{ para algum } r \in [m] 
    \end{array}                                 & \text{, caso contrário.}
\end{cases}
\end{equation*}

\begin{prop}
Para todo $n,m \geq 1$, $T(n,m) \leq (m+n)\lg(2n)$ e, portanto, a técnica da divisão e conquista consegue encontrar o máximo de todas as linhas em tempo $O((m+n)\lg(n))$
\end{prop}

\begin{proof}
Vamos usar indução em $n$ para provar a tese. Se $n = 1$ e $m \geq 1$, $T(1,m) = m \leq (m+1)\lg(2)$. Se $n = 2$ e $m \geq 1$, existe $r \in [m]$ tal que $T(2,m) = m + r \leq 2m \leq (m+2)\lg(4)$. Agora, se $n > 2$ e $m \geq 1$, existe um $r \in [m]$ tal que 
$$ T(n,m) = m + T(\ceil{n/2} - 1, r) + T(\floor{n/2}, m - r + 1) $$
assumimos que com $1 \leq n' < n$ e $m' \geq 1$ vale a tese para $T(n',m')$. Com isso, já que $1 \leq \ceil{n/2}-1 \leq n$, $1 \leq \floor{n/2} \leq n$, $r \geq 1$ e $m - r + 1 \geq 1$, temos, com a equação acima e o fato de que $\ceil{n/2}-1 \leq \floor{n/2} \leq n/2$,
\begin{align*} 
    T(n,m) & \leq & m + (r + \ceil{n/2} - 1 + m - r + 1 + \floor{n/2})\lg(n) \\
           & \leq & m + (m + n)\lg(n) \leq (m + n)(\lg(n) + 1) = (m + n)\lg(2n) \text{.}
\end{align*}
\end{proof}

\subsection{Implementação} \label{DivisaoEConquista_Implementacao}
Aqui serão discutidos os detalhes de implementação do algoritmo \ref{DivideAndConquer}.  

Primeiramente a matriz $A$ deve ser facilmente manipulada, não podemos gerar novas matrizes para alimentar as chamadas recursivas da função \hbox{\textsc{DivConq}}. Além disso, como explicado em \ref{Introducao_Implementacao}, o parâmetro a ser passado será uma função e não uma matriz. Note que a matriz nas chamadas recursivas é sempre formada por um intervalo das linhas e um intervalo das colunas da matriz $A$ original, portanto, podemos guardar 4 inteiros, $\ell s$, $\ell t$, $cs$ e $ct$, rempresentando, respectivamente, a primeira linha, a última linha, a primeira coluna e a última coluna acessíveis na chamada atual da recursão.  

Agora, devemos tomar cuidado com as atribuições feitas nas linhas \ref{DivideAndConquer:Div_left} e \ref{DivideAndConquer:Div_right}. A forma como elas foram apresentadas sugere que os vetores $R$ recebidos pelas funções sejam recebidos e copiados para o vetor $R$. Ao invés de fazer isso, iremos passar o endereço do vetor $R$ recursivamente e garantir que cada chamada só complete o subvetor $R[\ell s \tdots \ell t]$, referente a seu subproblema. Além disso, a linha \ref{DivideAndConquer:Div_right} possui uma adição, o que sugere que o valor $R[i]$ seja adicionado elemento-a-elemento, o que não será feito, os vetor $R$ já será preenchido com o índice correto da coluna na matriz original $A$ da primeira vez que for acessado.

\subsection{Aplicação em programação dinâmica} \label{DivisaoEConquista_PD}
A técnica da divisão e conquista pode ser aplicada para agilizar a solução de algus problemas de programação dinâmica. Aqui será apresentado um exemplo dessa aplicação.  

Sejam, $n,k \in \B{N}$ e $w \in \B{Q}_+^{n \times n}$ triângular superior (todos os valores $w(i,j)$ onde $i>j$ são indefinidos). Queremos calcular, para todo $n' \in [n]$ e $k' \in [k]$ os valores de
$$ f(k',n') = \begin{cases}
    w(1, n') & \text{, se } k' = 0 \text{ e }\\
    \max_{1 \leq i \leq n'} f(k'-1, i) + w(i,n') & \text{, caso contrário.}
\end{cases} $$

Este problema pode ser resolvido fácilmente em tempo $O(kn^2)$, porem, se $w$ for monótona convexa nas colunas, podemos aplicar a técnica da divisão e conquista para calcular todos os valores desejados em tempo $O(kn\lg(n))$. Definimos, para todo $1 \leq k' \leq k$ e $1 \leq i \leq n' \leq n$, a função $b_{k'}(i,n')$.

\begin{prop}
Para todo $k' \in [k]$, $b_{k'}$ é monótona convexa nas colunas.
\end{prop}

\begin{proof}
Indução em $k'$.
\end{proof}

Os valores de $f(0,n')$ podem ser descobertos em tempo costante. 
