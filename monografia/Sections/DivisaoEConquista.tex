\section{Divisão e conquista}
\label{DivConq}

%----------------------------------------------------------------------------------------

Nesta seção será apresentada uma técnica que chamamos de Otimização por divisão e conquista. A ideia é citada por Aggarwal~\cite{Aggarwal:1987} e é um tópico recorrente em competições de programação, sendo conhecida como ``Divide and Conquer Optimization''~\cite{Quora:DivConq,CF:Optm} e geralmente aplicada a problemas de programação dinâmica. 

Além disso, as hipóteses dos algoritmos decorrentes desta técnica são mais fracas do que as do algoritmo SMAWK, apresentado na Seção~\ref{SMAWK}, portanto, todo problema para o qual o SMAWK pode ser aplicado, esta técnica também pode. Ao final desta seção, apresentamos exemplos de aplicações em programação dinâmica.  

Dada uma matriz $A \in \B{Q}^{n \times m}$, listamos os casos de uso desta técnica:
\begin{itemize}
    \item Se $A$ é monótona nos mínimos das linhas podemos encontrar os índices de mínimos das linhas em tempo $\Cl{O}((n+m)\lg(n))$, 
    \item se $A$ é monótona nos máximos das linhas podemos encontrar os índices de máximos das linhas em tempo $\Cl{O}((n+m)\lg(n))$, 
    \item se $A$ é monótona nos mínimos das colunas podemos encontrar os índices de mínimos das colunas em tempo $\Cl{O}((n+m)\lg(m))$ e 
    \item se $A$ é monótona nos máximos das colunas podemos encontrar os índices de máximos das colunas em tempo $\Cl{O}((n+m)\lg(m))$.
\end{itemize}

Apresentaremos o caso em que $A$ é crescente nos mínimos das linhas. É fácil manipular o algoritmo resultante para trabalhar com os outros casos.

%----------------------------------------------------------------------------------------

\subsection{Técnica}
Dada uma matriz $A \in \B{Q}^{n \times m}$ monótona crescente nos mínimos das linhas, queremos encontrar o vetor de índices de mínimos das linhas de $A$. Isto é, para todo $i \in [n]$, queremos encontrar
$$ R[i] = \min\{j \mid A[i][j] \leq A[i][j'] \text{ para todo } j' \in [m]\} \text{.}$$  

Se, para alguma linha~$i$, encontrarmos o valor~$R[i]$, sabemos, pela monotonicidade de~$A$, que~${ R[i'] \leq R[i] }$ para todo~${ i' < i }$ eque~${ R[i'] \geq R[i] }$ para todo~${ i' > i }$, isto é, sabemos que os mínimos de menor índice das outras linhas se encontram nas submatrizes~${ A[1 \tdots i-1][1 \tdots R[i]] }$ e~${ A[i+1 \tdots n][R[i] \tdots m] }$. Seguindo o paradigma de divisão e conquista, vamos resolver o mesmo problema para estas submatrizes e, consequentemente, resolver o problema original. O Algoritmo~\ref{ DivConq:algo } implementa esta ideia.

\newcommand{\DivConq}{\textsc{DivConq}}
\begin{algorithm}[h]
\caption{Mínimos das linhas com divisão e conquista}
\label{ DivConq:algo }
\begin{algorithmic}[1]
\Function{\DivConq}{A, r_s, r_t, c_s, c_t, R}
    \If{ $r_s \leq r_t$ }
        \State $\ell \rec \ceil{ (r_s + r_t)/2 }$
        \State Guarda em $R[\ell]$ o índice de mínimo da linha~$\ell$ de~$A$. \label{ DivConq:algo:findmin }
        \State $\DivConq(A,r_s,\ell-1,c_s,R[l],R)$
        \State $\DivConq(A,\ell+1,r_t,R[l],c_t,R)$
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Note que, na linha~\ref{ DivConq:algo:findmin }, o mínimo só precisa ser buscado entre os índices~$c_s$ e~$c_t$, inclusive, pois estamos resolvendo o problema para a submatriz~$A[r_s \tdots r_t][c_s \tdots c_t]$. A implementação desta função em~\texttt{C++} pode ser encontrada no arquivo~\texttt{DivConq.cpp}.

Vamos realizar uma análise do tempo gasto pelo Algoritmo~\ref{ DivConq:algo } no pior caso. Se~$A$ é uma matriz e~${ r_s,r_t,c_s }$ e~$c_t$ são índices tais que~${ r_t - r_s + 1 = n \geq 0 }$ e~${ c_t - c_s + 1 = m > 0 }$, o tempo gasto por~$\DivConq(A,r_s,r_t,c_s,c_t,R)$ no pior caso pode ser expresso pela seguinte recorrência:
\begin{equation*}
\arraycolsep=2pt
T(n,m) = \left\{
\begin{array}{ll}
    1 &  \text{, se } n = 0 \text{ e } \\
    m + \max\limits_{j \in [m]}\{ T(\floor{ \frac{n}{2} },j) + T(\ceil{ \frac{n}{2} } - 1, m - j + 1) \} & \text{, caso contrário.} \\
\end{array}
\right.
\end{equation*}

Vamos provar que~$T(n,m) \leq (m+n)\lg(n + 2)$ para quaisquer dois inteiros~${ n \geq 0 }$ e~$m > 0$ usando indução em~$n$. Se~${ n = 0 }$, então~${ T(n,m) = T(0,m) = 1 \leq m = m\lg(2) =  (m + n)\lg(n+2) }$. Com~${ n > 1 }$ assumimos que a tese vale para todo~${ n' \in [n-1] }$ e, para todo~$m > 0$, sabemos que existe um~${ j \in [m] }$ tal que~${ T(n,m) = T(\floor{ \frac{n}{2} },j) + T(\ceil{ \frac{n}{2} } - 1, m - j + 1) }$. Já que tanto~$\floor{ \frac{n}{2} }$ quanto~$\ceil{ \frac{n}{2} } - 1$ estão em~$[n-1]$, aplicamos a hipótese de indução e obtemos que~${ T(n,m) \leq (\floor{ \frac{n}{2} } + j)\lg(\floor{ \frac{n}{2} } + 2) + (\ceil{ \frac{n}{2} } + m - j)\lg(\ceil{ \frac{n}{2} } + 1) }$. Com esta desigualdade, obtemos que~${ T(n,m) \leq (\floor{ \frac{n}{2} } + j)\lg(n + 2) + (\ceil{ \frac{n}{2} } + m - j)\lg(n + 2) = (n + m)\lg(n+2) }$, o que conclui esta prova.

\subsection{Aplicação em programação dinâmica} \label{DivConq:DP}
Utilizaremos a técnica apresentada aqui para resolver uma adaptação do problema ``Internet Trouble'' da Final Brasileira da Maratona de Programação de 2016. A prova em questão pode ser encontrada no link \url{http://maratona.ime.usp.br/hist/2016/resultados/contest.pdf}.  

\begin{prob} \label{DivConq:InternetTrouble}
Considere a função de custo~$c$ definida como~${ c(v) = \sum\limits_{i=1}^{|v|} \min\{i-1,m-i\} v_i }$ para cada vetor~${ v \in \B{Q}^n }$. Sejam~${ v \in \B{Z}_+^n }$ um vetor e~$k \in [n]$ um inteiro. Encontrar um particionamento~${ p_0 = 1 \leq p_1 \leq \dots \leq p_k = n + 1 }$ de~$v$ em~$k$ subvetores que minimize~${ \sum\limits_{ i = 1 }^k c(v[p_{i-1} \tdots p_i - 1]) }$.
\end{prob}

Podemos dar ao problema acima a interpretação do problema ``Internet Trouble'' citado. Temos~$n$ cidades numeradas de~$1$ até~$n$ dispostas em uma linha de forma que, para todo~$i,j \in [n]$, a distância entre as cidades~$i$ e~$j$ é~$|i-j|$. Queremos escolher~$k + 1$ destas cidades para instalar torres de distribuição de energia de forma a minimizar o custo de alimentar todas as cidades com energia sabendo que o custo de transferir energia de uma torre qualquer para uma cidade com~$h$ habitantes a uma distância~$d$ da torre é~$hd$ e que uma torre pode alimentar quantas cidades quiser. Nesta adaptação, as cidades~$1$ e~$n$ são escolhas obrigatórias para posições de torres. 

Definimos, para todo~$i,j \in [n]$ com~$i \leq j$, o custo~$A[i][j]$ de escolher o subvetor~$v[i \tdots j]$ como uma das partes. Os valores com índices de linhas maiores do que índices de colunas não fazem sentido na nossa modelagem, portanto, queremos torná-los inválidos. Já que o problema é de minimização, definimos seus valores como~$+\infty$. Assim, para~$i,j \in [n]$,
\begin{equation*}
A[i][j] = \begin{cases}
    c(v[i \tdots j]) & \text{, se } i \leq j \text{ e }\\
    +\infty          & \text{, c.c.}
\end{cases}
\end{equation*}

Para todo~$i,j \in [n]$ onde~$i \leq j$ definimos as funções~${ s(i,j) = \sum\limits_{p = i}^j (p-i)v_p }$ e~${ t(i,j) = \sum\limits_{p = i}^j (j-p)v_p }$. Com elas é fácil escrever~$A[i][j]$, basta escolher a média~${ r = \floor{\frac{i+j}{2}} }$ entre~$i$ e~$j$ e teremos~${ A[i][j] = s(i,r) + t(r+1,j) }$. Se pré processarmos os dois vetores~${ a,b \in \B{N}^{[0 \tdots n]} }$ onde, para todo~${ i \in [0 \tdots n] }$, vale que~${ a_i = \sum\limits_{p=1}^i v_p }$ e~${ b_i = \sum\limits_{p=1}^i pv_p }$ podemos calcular as funções~$s$ e~$t$ e, consequentemente, as entradas de~$A$ em tempo~$\Cl{O}(1)$. Basta escrever~${ s(i,j) = b_j - b_{i-1} - (a_j - a_{i-1})i }$ e~${ t(i,j) = (a_j - a_{i-1})j - b_j + b_{i-1} }$.

Queremos resolver o problema com programação dinâmica. Definimos, para todo~$\ell \in [k]$ e~$i \in [n]$, o subproblema de escolher escolher~$\ell$ dentre as cidades de índices em~${ [ i \tdots n] }$ para colocar estações de distribuição sendo que a cidade~$i$ é a única que já possui uma estação e a cidade~$n$ deve obrigatoriamente receber uma estação. Note que o valor em~$E[k][1]$ é o valor da resposta do problema original, por definição. Vale que~${ E[1][i] = A[i][n] }$ para todo~${ i \in [n] }$ já que é obrigatório colocar a única estação disponível em~$n$. Para todo~${ \ell \in [2 \tdots k] }$ vale que~${ E[\ell][i] = \min\{ E[\ell-1][j] + A[i][j] \mid j \in [i \tdots n] \} }$. Desta recorrência é fácil derivar um algoritmo de programação dinâmica cujo consumo de tempo é~$\Cl{O}(kn^2)$.

Vamos simplificar a recorrência obtida. Definimos, para cada~$\ell \in [2 \tdots k]$ a matriz~$B_\ell$ que guarda, em cada entrada~$i,j \in [n]$ o valor~${ A[i][j] + E[\ell - 1][j] }$. Assim, podemos reescrever~${ E[\ell][i] = \min\{ B_\ell[i][j] \mid j \in [n] \} }$, o que reduz o problema de encontrar os valores da matriz~$E$ ao problema de encontrar os mínimos das linhas de~$B_2$,~$B_3$, assim por diante até~$B_k$. Agora, estamos interessados em mostrar que as matrizes~$B_\ell$ são monótonas nos mínimos das linhas e aplicar a otimização da divisão e conquista em cada uma delas para resolver o problema original em tempo~$\Cl{O}(kn\lg(n))$.

Antes de mostrar a monotonicidade das matrizes~$B_\ell$, vamos obter um resultado útil para este fim. Tome os índices~${ i,j \in [n] }$ tais que~${ i \leq j }$ e a média~${ r = \floor{\frac{i+j}{2}} }$ entre eles. Se~${j-i}$ é ímpar, vale que~${ A[i][j+1] = s(i,r+1) + t(r+2,j+1) }$. Sabemos que valem as igualdades~${ s(i,r+1) = s(i,r) + (r+1-i)v_{r+1} }$ e~${ t(r +2,j+1) = t(r+1,j+1) - (j-r)v_{r+1} }$. Somando as duas obtemos~${ A[i][j+1] = s(i,r) + s(r+1,j+1) + (2r-i-j+1)v_{r+1} }$, porém~${ r + 1 = \frac{i+j+1}{2} }$, logo~${ A[i][j+1] = s(i,r) + s(t+1,j+1) }$. Se~${ j -i }$ é par, por definição, também vale~${ A[i][j+1] = s(i,r) + s(r+1,j+1) }$. Nos dois casos vale~${ A[i][j] = s(i,r) + s(r+1,j) }$ e, com isso, obtemos que~${ A[i][j+1] = A[i][j] + s(r+1,j+1) - s(r+1,j) = A[i][j] + \sum\limits_{p=r+1}^{j+1} v_p }$.

Agora, vamos provar que~$A$ é Monge côncava. Tome índices~${ i,j \in [n-1] }$ quaisquer. Se~${ i > j }$ vale que~${A[i][j] + A[i+1][j+1] \leq A[i+1][j] + A[i][j+1]}$ trivialmente já que~${ A[i][j+1] = +\infty }$ e~${A[i+1][j] \geq 0}$. Se~${ i \leq j }$ parágrafo acima sabemos que se~${ a = \floor{\frac{i+j}{2}} }$ e~${ b = \floor{\frac{i+j+1}{2}} }$ vale que~${ A[i][j+1] = A[i][j] + \sum\limits_{p=a}^{j+1} v_p }$ e~${A[i+1][j+1] = A[i+1][j] + \sum\limits_{p=b}^{j+1} v_p }$. Com isso temos que~${ A[i][j] + A[i+1][j+1] = A[i][j+1] - \sum\limits_{p=a}^{j+1} v_p + A[i+1][j] + \sum\limits_{p=b}^{j+1} v_p }$ e, já que~$a \leq b$, concluímos~${ A[i][j] + A[i+1][j+1] \geq A[i][j+1] + A[i+1][j] }$. Assim, pelo Teorema~\ref{Monge:theo+1},~$A$ é Monge côncava e pelo Teorema~$\ref{Monge:keepConvex}$ todas as matrizes~$B_\ell$ são Monge côncavas.

Já que as matrizes~$B_\ell$ são Monge côncavas, elas também são monótonas decrescentes nos mínimos das linhas e podemos aplicar a otimização da divisão e conquista para encontrar os mínimos das linhas de cada uma em tempo~$\Cl{O}(n\lg(n))$ resolvendo o problema proposto em tempo~$\Cl{O}(kn\lg(n))$. Vale notar que já que as matrizes~$B_\ell$ são Monge e não apenas monótonas, o algoritmo SMAWK apresentado na Seção~\ref{SMAWK} resolve o mesmo problema em tempo~$\Cl{O}(kn)$.
