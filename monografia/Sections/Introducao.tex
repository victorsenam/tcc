\section{Introdução}
\label{Introducao}

\subsection{Sobre o trabalho}
As matrizes Monge têm propriedades como a monotonicidade total e a monotonicidade, que são exploradas por uma série de algoritmos para a busca de máximos e mínimos em linhas e colunas destas matrizes. Algumas destas técnicas são populares pois são utilizadas para a agilização de problemas clássicos e aparecem com crescente frequência em competições de programação por sua utilidade na solução eficiente de problemas de programação dinâmica.

Busca-se neste trabalho formalizar, compilar e aprofundar os conhecimentos adquiridos sobre estes algoritmos por meio do estudo da literatura já existente a fim de facilitar o aprendizado destas técnicas. Além disso, procura-se generalizar os algoritmos inspirando-se em desafios propostos em competições, explorando suas limitações e modificando as formalizações encontradas na literatura para ampliar os escopos tradicionais. 

\subsection{Notação}
Se~$i$ e~$j$ são dois inteiros, a expressão~$[i \tdots j]$ denota o conjunto~${ \{ k \in \B{Z} \mid i \leq k \leq j \} }$, além disso, se~$n$ é inteiro~$[n]$ denota~$[1 \tdots n]$. Note que se~$i > j$, o conjunto~$[i \tdots j]$ é o conjunto vazio. Se~$v$ é um vetor, podemos escrever~$v[i \tdots j]$ para denotar o vetor~${ (v_i, v_{i+1}, \dots, v_j) }$. O mesmo vale em termos de submatrizes. Se~$r$ e~$\ell$ também são dois inteiros e~$A$ é uma matriz, podemos escrever~$A[i \tdots j][\ell \tdots r]$ para denotar a submatriz de~$A$ que contém apenas as linhas de~$A$ em~$[i \tdots j]$ e as colunas em~$[\ell \tdots r]$. Por padrão, nestes dois últimos casos, os subvetores e as submatrizes geradas são reindexados pelos conjuntos~$[j - i + 1]$ e~${ [j - i + 1] \times [r - \ell + 1] }$, respectivamente.

Se~$A$ e~$B$ são conjuntos, podemos escrever~$A^B$ para denotar o conjunto de vetores com entradas em~$A$ indexados pelos elementos de~$B$. Ainda se~$C$ também é um conjunto,~$A^{B \times C}$ denota o conjunto das matrizes com linhas indexadas por elementos de~$B$ e colunas indexadas por elementos de~$C$. Por exemplo, se~$v \in \B{R}^{ [3 \tdots 5] }$ então~$v$ é um vetor com entradas~${ v_3, v_4 }$ e~$v_5$. Definimos, ainda, para cada~$n$ e~$m$ inteiros, os conjuntos~${ \B{Q}^n = \B{Q}^{ [n] } }$ e~${ \B{Q}^{n \times m} = \B{Q}^{[n] \times [m]} }$.

\subsection{Implementações} \label{Intro:impl}
As implementações em \texttt{C++} das técnicas discutidas neste trabalho podem ser encontradas na pasta do trabalho em \texttt{implementacao/algoritmos}. O nome do arquivo é indicado no texto relacionado à técnica correspondente. Exemplos de uso dos algoritmos implementados podem ser encontrados em \texttt{implementacao/exemplos}.

Trabalharemos com funções que buscam certos valores em uma matriz sem analisar cada uma das posições da matriz. Por causa deste fato, não faz sentido construir explicitamente as matrizes para poder aplicar os algoritmos, já que isso custaria mais tempo do que o próprio algoritmo. Em vez de passar, como parâmetros das funções implementadas, matrizes, iremos passar três argumentos: uma função~$f$ e dois valores~$n$ e~$m$. Estes três parâmetros representam uma matriz~$A$ com~$n$ linhas e~$m$ colunas tal que, para cada~${ i \in [n] }$ e~${ j \in [m] }$, vale que~${ f(i,j) = A[i][j] }$. Na prática, isso significa que as matrizes com as quais trabalhamos têm entradas que podem ser calculadas de maneira eficiente quando necessário. Assumimos que cada chamada à função~$f$ custa tempo~$\Cl{O}(1)$.

Nos códigos, trabalhamos com matrizes, vetores e funções indexados por 0. Durante o texto os algoritmos e as análises apresentados são feitos baseando-se índices começados em 1. Esta mudança pode causar diferenças sutis do código em relação aos algoritmos apresentados no texto.

Cada técnica para encontrar valores ótimos de linhas de matrizes é implementada com uma classe que leva um nome relacionado ao algoritmo. A classe guarda uma representação da matriz no formato conveniente para o algoritmo. A classe \texttt{DivConq}, referente ao método da divisão e conquista explorado na Seção~\ref{DivConq}, por exemplo, guarda apenas a função~$A$ que representa a matriz e as dimensões,~$n$ e~$m$, da matriz representada.
