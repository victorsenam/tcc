\chapter{Introdução}
\label{Introducao}

\section{Conteúdo}
O conteúdo completo deste trabalho é acessível à partir do endereço~\href{http://linux.ime.usp.br/~victorsenam/mac0499}{http://linux.ime.usp.br/~victorsenam/mac0499}. Lá estão disponíveis links para este texto, o pôster de apresentação do trabalho e o diretório de implementações. Além disso, o código fonte completo do trabalho está disponível em~\href{http://github.com/victorsenam/tcc}{http://github.com/victorsenam/tcc}.

\section{Notação}
Se~$i$ e~$j$ são dois inteiros, a expressão~$[i \tdots j]$ denota o conjunto~${ \{ k \in \B{Z} \mid i \leq k \leq j \} }$, além disso, se~$n$ é inteiro~$[n]$ denota~$[1 \tdots n]$. Note que se~$i > j$, o conjunto~$[i \tdots j]$ é o conjunto vazio. Se~$v$ é um vetor, podemos escrever~$v[i \tdots j]$ para denotar o vetor~${ (v_i, v_{i+1}, \dots, v_j) }$. O mesmo vale em termos de submatrizes. Se~$r$ e~$\ell$ também são dois inteiros e~$A$ é uma matriz, podemos escrever~$A[i \tdots j][\ell \tdots r]$ para denotar a submatriz de~$A$ que contém apenas as linhas de~$A$ em~$[i \tdots j]$ e as colunas em~$[\ell \tdots r]$. Por padrão, nestes dois últimos casos, os subvetores e as submatrizes geradas são reindexados pelos conjuntos~$[j - i + 1]$ e~${ [j - i + 1] \times [r - \ell + 1] }$, respectivamente.

Se~$A$ e~$B$ são conjuntos, podemos escrever~$A^B$ para denotar o conjunto de vetores com entradas em~$A$ indexados pelos elementos de~$B$. Ainda se~$C$ também é um conjunto,~$A^{B \times C}$ denota o conjunto das matrizes com linhas indexadas por elementos de~$B$ e colunas indexadas por elementos de~$C$. Por exemplo, se~$v \in \B{R}^{ [3 \tdots 5] }$ então~$v$ é um vetor com entradas~${ v_3, v_4 }$ e~$v_5$. Definimos, ainda, para cada~$n$ e~$m$ inteiros e cada conjunto~$A$, os conjuntos~${ A^n = A^{ [n] } }$ e~${ A^{n \times m} = A^{[n] \times [m]} }$.

\section{Implementações} \label{Intro:impl}
As implementações em \texttt{C++} das técnicas discutidas neste trabalho podem ser encontradas no diretório de implementações na pasta \texttt{algoritmos}. O nome do arquivo é indicado no texto relacionado à técnica correspondente. Exemplos de uso dos algoritmos implementados podem ser encontrados na pasta \texttt{exemplos} e são documentados no Capítulo~\ref{Exemplos}.

Trabalharemos com funções que buscam certos valores em uma matriz sem analisar cada uma das posições da matriz. Por causa deste fato, não faz sentido construir explicitamente as matrizes para poder aplicar os algoritmos, já que isso custaria mais tempo do que o próprio algoritmo. Em vez de implementar os algoritmos sobre a representação usual de matrizes em~\texttt{C++}, com vetores bidimensionais, representaremos uma matriz com os seguintes elementos: uma função~$f$ e dois valores~$n$ e~$m$. Estes três parâmetros representam a matriz~$A$ com~$n$ linhas e~$m$ colunas tal que, para cada~${ i \in [n] }$ e~${ j \in [m] }$, vale que~${ f(i,j) = A[i][j] }$. Na prática, isso significa que as matrizes com as quais trabalhamos têm entradas que podem ser calculadas de maneira eficiente quando necessário. Assumimos que cada chamada à função~$f$ custa tempo~$\Cl{O}(1)$.

Nas implementações, trabalhamos com matrizes, vetores e funções indexados por 0. Durante o texto os algoritmos e as análises apresentados são feitos baseando-se índices começados em 1. Esta mudança pode causar diferenças sutis do código em relação aos algoritmos apresentados no texto.
