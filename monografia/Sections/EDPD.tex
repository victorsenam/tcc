\section{Estruturas de dados em programação dinâmica}
\label{EDPD}

Em certas ocasiões, ao aplicar programação dinâmica no cálculo de alguma recorrência, podemos manter alguns dos estados já calculados em uma estrutura de dados que pode nos ajudar a calcular com mais eficiência os estados seguintes. Nesta seção, exemplificaremos esta possibilidade. 

Na Seção~\ref{Online} apresentaremos um exemplo no qual a convexidade (ou concavidade) da recorrência calculada nos permite usar uma estrutura de dados de forma parecida com a apresentada aqui. Esta seção, portanto, pretende ser uma introdução à utilização de estruturas de dados em programação dinâmica que deve facilitar a compreensão da Seção~\ref{Online}.

%----------------------------------------------------------------------------------------

\subsection{O problema da subsequência crescente de peso máximo}

\begin{prob}[Subsequência crescente de peso máximo] \label{EDPD:HIS}
Dados um natural~$n$ e dois vetores~$v,w \in \B{Q}^n$, descobrir uma subsequência~$s$ de~$[1 \tdots n]$ crescente em~$v$ e de soma máxima em~$w$. Formalmente, a subsequência~$s$ deve respeitar~${ v_{s_i} < v_{s_j} }$ para todo par de índices~${ i,j \in [1 \tdots |s|] }$ tal que~${ i < j }$ e deve maximizar~${ \sum\limits_{i \in s} w_i }$.
\end{prob}

Podemos resolver este problema com tempo~$\Cl{O}(n^2)$ utilizando programação dinâmica na recorrência
\begin{equation} \label{EDPD:HIS:rec}
f(i) = \max(\{f(j) \mid j < i \text{ e } v_j < v_i\} \cup \{0\}) + w_j \text{,}
\end{equation}
onde, para todo~$i \in [1 \tdots n]$, o valor~$f(i)$ é o peso da melhor sequência válida que contém~$i$ como último elemento.

Um caso especial deste problema onde o vetor~$w$ é um vetor unitário é o problema clássico da maior subsequência crescente. É conhecido o fato de que este problema pode ser resolvido em tempo~$O(n\lg(n))$~\cite{Fredman:1975}. 

%----------------------------------------------------------------------------------------

\subsection{Fronteira de Pareto}

Apresentaremos uma estrutura de dados que vai nos ajudar a resolver o Problema~\ref{EDPD:HIS} em tempo~$\Cl{O}(n\lg(n))$, para isso, vamos utilizar algumas definições e resultados.

\begin{defi}[Relação de dominância]
Sejam~${ a = (a_1,a_2) }$ e~${ b = (b_1,b_2) }$ elementos de~$\B{Q}^2$. Se~${ a_1 \geq b_1 }$ e~${ a_2 \geq b_2 }$ dizemos que~${ a \succeq b }$ ($a$ domina~$b$). Além disso, se~${ S \subseteq \B{Q}^2 }$, um ponto~${ a \in \B{Q} }$ é dominado em~$S$ se existe um outro ponto~$b \in S$ que domina~$a$.
\end{defi}

\begin{prop}
A relação de dominância é uma ordem parcial~\cite[Apêndice B]{CLRS} em~$\B{Q}^2$.
\end{prop}
\begin{proof}
Sobre a relação~$\succeq$ valem as propriedades:
\begin{description}
\item[Reflexiva] Se~$a = (a_1,a_2) \in \B{Q}^2$, vale~$a_1 \geq a_1$ e~$a_2 \geq a_2$, portanto~$a \succeq a$.
\item[Antissimétrica] Se~$a = (a_1,a_2)$ e~$b = (b_1,b_2) \in \B{Q}^2$ são tais que~$a \succeq b$ e~$b \succeq a$, vale~$a_1 = b_1$ e~$a_2 = b_2$, portanto~$a = b$.
\item[Transitiva] Se~$a = (a_1,a_2), b = (b_1,b_2)$ e~$c = (c_1,c_2) \in \B{Q}^2$ são tais que~$a \succeq b$ e~$b \succeq c$,~$a_1 \geq c_1$ e~$a_2 \geq c_2$, logo,~$a \succeq c$.
\end{description}
Logo,~$\succeq$ define uma ordem parcial sobre~$\B{Q}^2$.
\end{proof}

Além disso, o valor a seguir será de interesse sobre os conjuntos nos quais trabalharemos neste problema.
\begin{defi}
Dados~$S \subset \B{Q}^2$ finito e~$c \in \B{Q}$, definimos~${M(S,c) = \max\{a_2 \mid (a_1,a_2) \in S \text{ e } a_1 \geq c\}}$.
\end{defi}

Com estas definições estamos prontos para apresentar a estrutura de dados que vai nos ajudar a resolver o Problema~\ref{EDPD:HIS}.
\begin{defi}[Fronteira de Pareto] \label{EDPD:Pareto}
A fronteira de Pareto~$\Cl{P}(S)$ de um conjunto finito~$S \subset \B{Q}^2$ é uma estrutura de dados que contém todos os elementos não dominados de~$S$, isto é, $x \in \Cl{P}(S)$ se e somente se $x \in S$ e $x$ não é dominado em $S$. Podemos realizar as seguintes operações sobre~$\Cl{P}(S)$:

\begin{description}
\item[$\textsc{Insere}(x)$] Inserir um novo elemento~$x \in \B{Q}^2$ em~$S$ em tempo~$\Cl{O}(\lg(|S|))$ amortizado.
\item[$\textsc{CalculaM}(c)$] Descobrir, dado um~$c \in \B{Q}$ o valor~$M(S,c)$ em tempo~$\Cl{O}(\lg(|S|))$.
\end{description}
\end{defi}

Para implementar esta estrutura de dados, vamos manter os elementos de~$\Cl{P}(S)$ em uma árvore de busca binária ordenada pela primeira coordenada. Esta ordenação nos garante uma propriedade poderosa descrita pela Proposição~\ref{EDPD:doubleorder}.

\begin{prop} \label{EDPD:doubleorder}
Se~$S \subset \B{Q}^2$ é finito e os elementos de~$\Cl{P}(S)$ estão em ordem crescente na primeira coordenada, eles estão em ordem decrescente na segunda coordenada.
\end{prop}
\begin{proof}
Suponha que existam~$x = (x_1,x_2)$ e~$y = (y_1,y_2) \in \Cl{P}(S)$ tais que~$x_1 \leq x_2$ e~$y_1 \leq y_2$, assim,~$y \succeq x$ e~$x \notin \Cl{P}(S)$.
\end{proof}

Com isso, para calcular~$M(\Cl{P}(S),c)$ basta encontrar o elemento em~$\Cl{P}(S)$ com menor primeira coordenada que seja maior ou igual a~$c$ e devolver a segunda coordenada deste ponto. Isso funciona por sabermos que qualquer elemento que tenha maior valor na primeira coordenada do que o encontrado terá menor valor na segunda. É possível encontrar este elemento em tempo~$\Cl{O}(\lg(|\Cl{P}(S)|))$, já que a nossa estrutura mantém uma árvore de busca binária dos elementos ordenada pela primeira coordenada. 

A Proposição~\ref{EDPD:keepM} abaixo garante que~${ M(\Cl{P}(S),c) = M(S,c) }$, portanto, realizar esta busca na estrutura responde à operação~$\textsc{CalculaM}$. Já que~${\Cl{O}(\lg(|\Cl{P}(S)|)) \subseteq \Cl{O}(\lg(|S|))}$, esta busca e, consequentemente, o cálculo da operação~$\textsc{CalculaM}$, são realizados em tempo~$\Cl{ O(\lg(|S|) }$.

\begin{prop} \label{EDPD:keepM}
Para todo~$S \subset \B{Q}^2$ finito e~$c \in \B{Q}$ vale~$M(S,c) = M(\Cl{P}(S),c)$.
\end{prop}
% TODO REVISAR ESSA PROVA
\begin{proof}
Sabemos~$M(S,c) \geq M(\Cl{P}(S),c)$. Se~$S = \emptyset$, vale~${M(S,c) = M(\Cl{P}(S),c) = -\infty}$. Suponha~$S \neq \emptyset$, existe~$a=(a_1,a_2) \in S$ tal que~$M(S,c) = a_2$ e~$a_1 \geq c$. Se~$a \in \Cl{P}(S)$, vale que~${ M(\Cl{P}(S),c) \geq M(S,c) }$. Se~${ a \notin \Cl{P}(S) }$, pela Proposição~\ref{EDPD:DomP}, existe~$b =(b_1,b_2)$ tal que~$b \in \Cl{P}(S)$ e~$b \succeq a$, portanto, já que~$b_1 \geq a_1 \geq c$, vale que~$M(\Cl{P}(S),c) \geq b_2 \geq a_2 = M(S,c)$. Concluímos que~${ M(S,c) = M(\Cl{P}(S),c) }$.
\end{proof}

Devemos conseguir realizar a operação~$\textsc{Insere}$. Suponha que estamos interessados em inserir um ponto~$x = (x_1,x_2)$ dado. Note que a estrutura deve manter apenas os pontos não dominados de~$S$, para isso, antes de inserir~$x$, devemos descobrir se ele é dominado por ou domina alguém de~$S$ olhando apenas para os elementos da estrutura, o que é possível graças à proposição abaixo.

\begin{prop} \label{EDPD:DomP}
Se~$S$ é um conjunto finito e um ponto~$x \in \B{Q}^2$ é dominado em~$S$, então,~$x$ é dominado em~$\Cl{P}(S)$.
\end{prop}
\begin{proof}
Seja~$y \in S$ tal que~$y \succeq x$, usaremos indução na quantidade de pontos que dominam~$y$ em~$S$ para mostrar que~$y \in \Cl{P}(S)$ ou~$y$ é dominado em~$\Cl{P}(S)$. Na base, existe apenas um ponto em~$S$ que domina~$y$, ele próprio, assim~$y \in \Cl{P}(S)$, caso contrário, existe um outro ponto~$z$ em~$S$ que domina~$y$ e, por transitividade, é dominado por estritamente menos pontos do que~$y$, pela hipótese de indução, temos dois casos, no primeiro~$z \in \Cl{P}(S)$ e~$y$ é dominado em~$\Cl{P}(S)$, no outro,~$z$ é dominado em~$\Cl{P}(S)$ e, por transitividade,~$y$ também é, assim, está provada a tese. Finalmente, já que~$y \succeq x$ e~$\succeq$ é transitiva~$x$ é dominado em~$\Cl{P}(S)$.
\end{proof}

Precisamos remover todos os elementos da estrutura que são dominados por~$x$. Suponha que existem dois elementos~$a = (a_1,a_2)$ e~$b = (b_1,b_2)$ na estrutura onde~$x_1 \geq a_1 \geq b_1$ e~$x \succeq b$, já que, pela Proposição~\ref{EDPD:doubleorder}, temos~$a_1 \leq b_1$, sabemos que~$x \succeq a$. Assim, basta encontrar o último elemento com primeira coordenada menor ou igual a~$x_1$ e, caso ele seja dominado por~$x$, removê-lo e repetir o processo, caso contrário, parar com a garantia de que nenhum elemento da estrutura é dominado por~$x$. Estas buscas e remoções podem ser feitas em tempo~$\Cl{O}(\lg(|S|))$, já que estamos usando uma árvore de busca binária. Além disso, precisamos descobrir se~$x$ é dominado por algum elemento, para isso, calculamos o valor~$M(S,x_1)$. Se este valor for pelo menos~$x_2$ existe um elemento exatamente igual a~$x$ na estrutura ou~$x$ é dominado por outro elemento da estrutura, em ambos os casos, não inserimos~$x$ na estrutura, caso contrário, basta inserir~$x$ na estrutura.

Note que todo elemento pode ser removido da estrutura apenas uma vez e que descobrir se um elemento não entra na estrutura pede apenas uma chamada ao método~$\textsc{CalculaM}$. Isso mostra que a operação~$\textsc{Insere}$ é realizada em tempo amortizado~$\Cl{O}(\lg(|S|)$. O Algoritmo~\ref{EDPD:FP:code} implementa as operações descritas aqui.

\begin{algorithm}[h]
\caption{Operações sobre a fronteira de Pareto de um conjunto}
\label{EDPD:FP:code}
\begin{algorithmic}[1]
\Function{\textsc{Insere}}{\Cl{P}(S),x = (x_1,x_2)}
    \State $y = (y_1,y_2) \rec$ último elemento tal que~$y_1 \leq x_1$
    \While{ $y$ existe e $x \succeq y$}
        \State Remove~$y$ da árvore de busca de~$\Cl{P}(S)$
        \State $y = (y_1,y_2) \rec$ último elemento tal que~$y_1 \leq x_1$
    \EndWhile
    \If{$\textsc{CalculaM}(\Cl{P}(S),x_1) < x_2$}
        \State Insere~$x$ na árvore de busca de~$\Cl{P}(S)$
    \EndIf
\EndFunction
\Function{\textsc{CalculaM}}{\Cl{P}(S),c}
    \State $y = (y_1,y_2) \rec$ primeiro elemento tal que~$y_1 \geq c$
    \If{$y$ existe}
        \State \Return $y_2$
    \Else
        \State \Return $-\infty$
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


%----------------------------------------------------------------------------------------

\subsection{Otimizando subsequência crescente de peso máximo}

Com a possibilidade de manter a fronteira de Pareto de um subconjunto finito de~$\B{Q}^2$, vamos calcular cada~$f(i)$ definido na solução original do Problema~\ref{EDPD:HIS} em tempo~$\Cl{O}(\lg(n))$. Para isso basta notar que podemos reescrever a recorrência~\ref{EDPD:HIS:rec} como~$f(i) = M(S_i,-v_i)$ onde~$S_i = \{(-v_j,f(j)) \mid j < i\} \cup \{(0,\infty)\}$. Com isso, o Algoritmo~\ref{EDPD:HIS:code} calcula todos os~$f$ em tempo~$\Cl{O}(n\lg(n))$.

\begin{algorithm}[h]
\caption{Solução do Problema~\ref{EDPD:HIS}}
\label{EDPD:HIS:code}
\begin{algorithmic}[1]
\Function{\textsc{SubsequênciaCrescentePesoMáximo}}{n,v,w}
    \State Inicializa a fronteira de Pareto~$P$ com o elemento~$(0,\infty)$
    \State $r \rec 0$
    \For{$i$ de $1$ até $n$}
        \State $f(i) = \textsc{CalculaM}(P,-v_i)$
        \State $\textsc{Insere}(P,(f(i),-v_i))$
        \State $r \rec \max(r,f(i))$
    \EndFor
    \State \Return $r$
\EndFunction
\end{algorithmic}
\end{algorithm}
